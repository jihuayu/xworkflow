// Additional tests to add to cache.rs

#[tokio::test]
async fn test_cache_different_groups_isolated() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: None,
    });

    let yaml1 = sample_yaml();
    let yaml2 = r#"
version: "0.1.0"
nodes:
  - id: start
    data:
      type: start
      title: Start2
  - id: end
    data:
      type: end
      title: End2
edges:
  - source: start
    target: end
"#;

    let compiled_a = cache
        .get_or_compile("group_a", yaml1, DslFormat::Yaml)
        .unwrap();
    let compiled_b = cache
        .get_or_compile("group_b", yaml2, DslFormat::Yaml)
        .unwrap();

    assert!(!Arc::ptr_eq(&compiled_a, &compiled_b));
    
    let stats = cache.stats();
    assert_eq!(stats.group_count, 2);
    assert_eq!(stats.total_entries, 2);
}

#[tokio::test]
async fn test_cache_eviction_per_group() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 2,
        max_total_entries: 100,
        ttl: None,
    });

    let yaml1 = sample_yaml();
    let yaml2 = yaml1.replace("Start", "Start2");
    let yaml3 = yaml1.replace("Start", "Start3");

    cache.get_or_compile("group_a", &yaml1, DslFormat::Yaml).unwrap();
    cache.get_or_compile("group_a", &yaml2, DslFormat::Yaml).unwrap();
    cache.get_or_compile("group_a", &yaml3, DslFormat::Yaml).unwrap();

    let group_stats = cache.group_stats("group_a").unwrap();
    assert_eq!(group_stats.entries, 2);
}

#[tokio::test]
async fn test_cache_global_eviction() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 3,
        ttl: None,
    });

    for i in 0..5 {
        let yaml = sample_yaml().replace("Start", &format!("Start{}", i));
        cache.get_or_compile(&format!("group_{}", i), &yaml, DslFormat::Yaml).unwrap();
    }

    let stats = cache.stats();
    assert!(stats.total_entries <= 3);
}

#[tokio::test]
async fn test_cache_invalidate() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: None,
    });

    let yaml = sample_yaml();
    cache.get_or_compile("group_a", yaml, DslFormat::Yaml).unwrap();
    
    let content_hash = WorkflowCache::hash_content(yaml);
    cache.invalidate("group_a", content_hash);
    
    let group_stats = cache.group_stats("group_a").unwrap();
    assert_eq!(group_stats.entries, 0);
}

#[tokio::test]
async fn test_cache_clear_group() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: None,
    });

    cache.get_or_compile("group_a", sample_yaml(), DslFormat::Yaml).unwrap();
    cache.get_or_compile("group_b", sample_yaml(), DslFormat::Yaml).unwrap();
    
    cache.clear_group("group_a");
    
    assert_eq!(cache.group_stats("group_a"), None);
    assert!(cache.group_stats("group_b").is_some());
}

#[tokio::test]
async fn test_cache_clear_all() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: None,
    });

    cache.get_or_compile("group_a", sample_yaml(), DslFormat::Yaml).unwrap();
    cache.get_or_compile("group_b", sample_yaml(), DslFormat::Yaml).unwrap();
    
    cache.clear_all();
    
    let stats = cache.stats();
    assert_eq!(stats.group_count, 0);
    assert_eq!(stats.total_entries, 0);
}

#[tokio::test]
async fn test_cache_ttl_expiration() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: Some(Duration::from_millis(50)),
    });

    cache.get_or_compile("group_a", sample_yaml(), DslFormat::Yaml).unwrap();
    
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Should recompile due to expiration
    let compiled = cache.get_or_compile("group_a", sample_yaml(), DslFormat::Yaml).unwrap();
    assert!(compiled.schema().nodes().len() > 0);
}

#[tokio::test]
async fn test_cache_by_workflow_id() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: None,
    });

    let yaml = sample_yaml();
    let compiled_a = cache
        .get_or_compile_by_id("group_a", "workflow_1", yaml, DslFormat::Yaml)
        .unwrap();
    let compiled_b = cache
        .get_or_compile_by_id("group_a", "workflow_1", yaml, DslFormat::Yaml)
        .unwrap();

    assert!(Arc::ptr_eq(&compiled_a, &compiled_b));
}

#[tokio::test]
async fn test_cache_access_count_updates() {
    let cache = WorkflowCache::new(WorkflowCacheConfig {
        max_entries_per_group: 10,
        max_total_entries: 100,
        ttl: None,
    });

    let yaml = sample_yaml();
    cache.get_or_compile("group_a", yaml, DslFormat::Yaml).unwrap();
    cache.get_or_compile("group_a", yaml, DslFormat::Yaml).unwrap();
    cache.get_or_compile("group_a", yaml, DslFormat::Yaml).unwrap();
    
    // The cache should still contain the entry
    let group_stats = cache.group_stats("group_a").unwrap();
    assert_eq!(group_stats.entries, 1);
}
