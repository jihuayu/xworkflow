# ä»£ç æ²™ç®±è®¾è®¡æ–‡æ¡£

## æ–‡æ¡£ç‰ˆæœ¬
- **ç‰ˆæœ¬**: v2.0
- **æ—¥æœŸ**: 2026-02-09
- **çŠ¶æ€**: è®¾è®¡é˜¶æ®µ

## ç›®å½•
1. [æ¦‚è¿°](#1-æ¦‚è¿°)
2. [é€šç”¨æ¥å£è®¾è®¡](#2-é€šç”¨æ¥å£è®¾è®¡)
3. [V8 å®ç°](#3-v8-å®ç°)
4. [å…¶ä»–å®ç°æ–¹æ¡ˆ](#4-å…¶ä»–å®ç°æ–¹æ¡ˆ)
5. [æ¶æ„è®¾è®¡](#5-æ¶æ„è®¾è®¡)
6. [å®‰å…¨æœºåˆ¶](#6-å®‰å…¨æœºåˆ¶)
7. [API è®¾è®¡](#7-api-è®¾è®¡)
8. [å®ç°ç»†èŠ‚](#8-å®ç°ç»†èŠ‚)
9. [æ€§èƒ½ä¼˜åŒ–](#9-æ€§èƒ½ä¼˜åŒ–)
10. [æµ‹è¯•ç­–ç•¥](#10-æµ‹è¯•ç­–ç•¥)
11. [ä½¿ç”¨ç¤ºä¾‹](#11-ä½¿ç”¨ç¤ºä¾‹)
12. [é£é™©ä¸é™åˆ¶](#12-é£é™©ä¸é™åˆ¶)

---

## 1. æ¦‚è¿°

### 1.1 ç›®æ ‡

ä¸º xworkflow çš„ Code èŠ‚ç‚¹è®¾è®¡ä¸€ä¸ªé€šç”¨çš„ä»£ç æ‰§è¡Œæ²™ç®±æ¥å£ï¼Œæ”¯æŒå¤šç§å®ç°æ–¹å¼ï¼š
- **V8 å¼•æ“**: åµŒå…¥å¼ JavaScript æ‰§è¡Œï¼ˆé»˜è®¤å®ç°ï¼‰
- **WebAssembly**: é«˜æ€§èƒ½äºŒè¿›åˆ¶ä»£ç æ‰§è¡Œ
- **è¿œç¨‹æ²™ç®±**: é€šè¿‡ HTTP/gRPC è°ƒç”¨å¤–éƒ¨æ²™ç®±æœåŠ¡
- **å…¶ä»–è¯­è¨€**: Pythonã€Lua ç­‰ï¼ˆæœªæ¥æ‰©å±•ï¼‰

### 1.2 è®¾è®¡åŸåˆ™

- **æ¥å£ç»Ÿä¸€**: æ‰€æœ‰å®ç°éµå¾ªç›¸åŒçš„ trait æ¥å£
- **å¯æ’æ‹”**: æ”¯æŒè¿è¡Œæ—¶åˆ‡æ¢ä¸åŒçš„æ²™ç®±å®ç°
- **å‘åå…¼å®¹**: æ–°å¢å®ç°ä¸å½±å“ç°æœ‰ä»£ç 
- **æ€§èƒ½ä¼˜å…ˆ**: é»˜è®¤ä½¿ç”¨é«˜æ€§èƒ½çš„æœ¬åœ°å®ç°
- **å®‰å…¨ç¬¬ä¸€**: æ‰€æœ‰å®ç°éƒ½å¿…é¡»æä¾›å®‰å…¨éš”ç¦»

### 1.3 æ ¸å¿ƒç‰¹æ€§

- âœ… **ç»Ÿä¸€æ¥å£**: é€šè¿‡ `CodeSandbox` trait å®šä¹‰æ ‡å‡†æ¥å£
- ğŸ”Œ **å¤šç§å®ç°**: V8ã€WASMã€è¿œç¨‹è°ƒç”¨ç­‰
- âš¡ **é«˜æ€§èƒ½**: æœ¬åœ°æ‰§è¡Œä¼˜å…ˆï¼Œè¿œç¨‹è°ƒç”¨ä½œä¸ºå¤‡é€‰
- ğŸ”’ **å®‰å…¨éš”ç¦»**: æ‰€æœ‰å®ç°éƒ½æä¾›èµ„æºé™åˆ¶å’Œå®‰å…¨æœºåˆ¶
- ğŸ“Š **å¯è§‚æµ‹**: ç»Ÿä¸€çš„ç›‘æ§å’Œæ—¥å¿—æ¥å£

---

## 2. é€šç”¨æ¥å£è®¾è®¡

### 2.1 æ ¸å¿ƒ Trait å®šä¹‰

```rust
use async_trait::async_trait;
use serde_json::Value;
use std::time::Duration;

/// ä»£ç æ²™ç®±æ‰§è¡Œæ¥å£
///
/// æ‰€æœ‰æ²™ç®±å®ç°ï¼ˆV8ã€WASMã€è¿œç¨‹è°ƒç”¨ç­‰ï¼‰éƒ½å¿…é¡»å®ç°æ­¤ trait
#[async_trait]
pub trait CodeSandbox: Send + Sync {
    /// æ²™ç®±ç±»å‹æ ‡è¯†
    fn sandbox_type(&self) -> SandboxType;

    /// æ”¯æŒçš„è¯­è¨€åˆ—è¡¨
    fn supported_languages(&self) -> Vec<CodeLanguage>;

    /// æ‰§è¡Œä»£ç 
    ///
    /// # å‚æ•°
    /// - `request`: æ‰§è¡Œè¯·æ±‚ï¼ŒåŒ…å«ä»£ç ã€è¾“å…¥ã€é…ç½®ç­‰
    ///
    /// # è¿”å›
    /// - `Ok(SandboxResult)`: æ‰§è¡ŒæˆåŠŸï¼Œè¿”å›ç»“æœ
    /// - `Err(SandboxError)`: æ‰§è¡Œå¤±è´¥
    async fn execute(&self, request: SandboxRequest) -> Result<SandboxResult, SandboxError>;

    /// éªŒè¯ä»£ç ï¼ˆå¯é€‰ï¼Œç”¨äºæå‰æ£€æŸ¥ï¼‰
    async fn validate(&self, code: &str, language: CodeLanguage) -> Result<(), SandboxError> {
        // é»˜è®¤å®ç°ï¼šä¸åšéªŒè¯
        Ok(())
    }

    /// å¥åº·æ£€æŸ¥
    async fn health_check(&self) -> Result<HealthStatus, SandboxError> {
        Ok(HealthStatus::Healthy)
    }

    /// è·å–èµ„æºä½¿ç”¨æƒ…å†µ
    async fn get_stats(&self) -> Result<SandboxStats, SandboxError> {
        Ok(SandboxStats::default())
    }
}

/// æ²™ç®±ç±»å‹
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SandboxType {
    /// V8 JavaScript å¼•æ“
    V8,
    /// WebAssembly
    Wasm,
    /// è¿œç¨‹æ²™ç®±æœåŠ¡
    Remote,
    /// Python è§£é‡Šå™¨
    Python,
    /// Lua è§£é‡Šå™¨
    Lua,
}

/// æ”¯æŒçš„ç¼–ç¨‹è¯­è¨€
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CodeLanguage {
    JavaScript,
    TypeScript,
    Python,
    Lua,
    Wasm,
}

/// æ²™ç®±æ‰§è¡Œè¯·æ±‚
#[derive(Debug, Clone)]
pub struct SandboxRequest {
    /// ä»£ç å†…å®¹
    pub code: String,

    /// ç¼–ç¨‹è¯­è¨€
    pub language: CodeLanguage,

    /// è¾“å…¥æ•°æ®
    pub inputs: Value,

    /// æ‰§è¡Œé…ç½®
    pub config: ExecutionConfig,
}

/// æ‰§è¡Œé…ç½®
#[derive(Debug, Clone)]
pub struct ExecutionConfig {
    /// æ‰§è¡Œè¶…æ—¶
    pub timeout: Duration,

    /// æœ€å¤§å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
    pub max_memory: usize,

    /// æœ€å¤§ CPU æ—¶é—´ï¼ˆç§’ï¼‰
    pub max_cpu_time: Option<Duration>,

    /// ç¯å¢ƒå˜é‡
    pub env_vars: HashMap<String, String>,
}

impl Default for ExecutionConfig {
    fn default() -> Self {
        Self {
            timeout: Duration::from_secs(30),
            max_memory: 128 * 1024 * 1024,  // 128MB
            max_cpu_time: None,
            env_vars: HashMap::new(),
        }
    }
}

/// æ²™ç®±æ‰§è¡Œç»“æœ
#[derive(Debug, Clone)]
pub struct SandboxResult {
    /// æ‰§è¡Œæ˜¯å¦æˆåŠŸ
    pub success: bool,

    /// è¾“å‡ºæ•°æ®
    pub output: Value,

    /// æ ‡å‡†è¾“å‡º
    pub stdout: String,

    /// æ ‡å‡†é”™è¯¯
    pub stderr: String,

    /// æ‰§è¡Œæ—¶é—´
    pub execution_time: Duration,

    /// å†…å­˜ä½¿ç”¨ï¼ˆå­—èŠ‚ï¼‰
    pub memory_used: usize,

    /// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœå¤±è´¥ï¼‰
    pub error: Option<String>,
}

/// å¥åº·çŠ¶æ€
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum HealthStatus {
    Healthy,
    Degraded,
    Unhealthy,
}

/// æ²™ç®±ç»Ÿè®¡ä¿¡æ¯
#[derive(Debug, Clone, Default)]
pub struct SandboxStats {
    /// æ€»æ‰§è¡Œæ¬¡æ•°
    pub total_executions: u64,

    /// æˆåŠŸæ¬¡æ•°
    pub successful_executions: u64,

    /// å¤±è´¥æ¬¡æ•°
    pub failed_executions: u64,

    /// å¹³å‡æ‰§è¡Œæ—¶é—´
    pub avg_execution_time: Duration,

    /// å¹³å‡å†…å­˜ä½¿ç”¨
    pub avg_memory_used: usize,
}

/// æ²™ç®±é”™è¯¯
#[derive(Debug, thiserror::Error)]
pub enum SandboxError {
    #[error("Unsupported language: {0:?}")]
    UnsupportedLanguage(CodeLanguage),

    #[error("Code too large (max {max} bytes, got {actual} bytes)")]
    CodeTooLarge { max: usize, actual: usize },

    #[error("Dangerous code detected: {0}")]
    DangerousCode(String),

    #[error("Compilation error: {0}")]
    CompilationError(String),

    #[error("Execution error: {0}")]
    ExecutionError(String),

    #[error("Type error: {0}")]
    TypeError(String),

    #[error("Memory limit exceeded")]
    MemoryLimitExceeded,

    #[error("Execution timeout")]
    ExecutionTimeout,

    #[error("Serialization error: {0}")]
    SerializationError(String),

    #[error("Sandbox unavailable: {0}")]
    SandboxUnavailable(String),

    #[error("Internal error: {0}")]
    InternalError(String),
}
```

### 2.2 æ²™ç®±ç®¡ç†å™¨

```rust
/// æ²™ç®±ç®¡ç†å™¨ - ç®¡ç†å¤šä¸ªæ²™ç®±å®ç°
pub struct SandboxManager {
    /// é»˜è®¤æ²™ç®±
    default_sandbox: Arc<dyn CodeSandbox>,

    /// æŒ‰è¯­è¨€æ³¨å†Œçš„æ²™ç®±
    sandboxes: HashMap<CodeLanguage, Arc<dyn CodeSandbox>>,

    /// é…ç½®
    config: SandboxManagerConfig,
}

impl SandboxManager {
    /// åˆ›å»ºæ–°çš„æ²™ç®±ç®¡ç†å™¨
    pub fn new(config: SandboxManagerConfig) -> Self {
        let mut manager = Self {
            default_sandbox: Arc::new(V8Sandbox::new(config.v8_config.clone())),
            sandboxes: HashMap::new(),
            config,
        };

        // æ³¨å†Œé»˜è®¤æ²™ç®±
        manager.register_sandbox(
            CodeLanguage::JavaScript,
            Arc::new(V8Sandbox::new(config.v8_config.clone()))
        );

        manager
    }

    /// æ³¨å†Œæ²™ç®±å®ç°
    pub fn register_sandbox(
        &mut self,
        language: CodeLanguage,
        sandbox: Arc<dyn CodeSandbox>,
    ) {
        self.sandboxes.insert(language, sandbox);
    }

    /// æ‰§è¡Œä»£ç ï¼ˆè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„æ²™ç®±ï¼‰
    pub async fn execute(
        &self,
        request: SandboxRequest,
    ) -> Result<SandboxResult, SandboxError> {
        // æ ¹æ®è¯­è¨€é€‰æ‹©æ²™ç®±
        let sandbox = self.sandboxes
            .get(&request.language)
            .unwrap_or(&self.default_sandbox);

        // æ£€æŸ¥æ²™ç®±æ˜¯å¦æ”¯æŒè¯¥è¯­è¨€
        if !sandbox.supported_languages().contains(&request.language) {
            return Err(SandboxError::UnsupportedLanguage(request.language));
        }

        // æ‰§è¡Œä»£ç 
        sandbox.execute(request).await
    }

    /// è·å–æ‰€æœ‰æ²™ç®±çš„å¥åº·çŠ¶æ€
    pub async fn health_check_all(&self) -> HashMap<SandboxType, HealthStatus> {
        let mut statuses = HashMap::new();

        for sandbox in self.sandboxes.values() {
            let status = sandbox.health_check().await.unwrap_or(HealthStatus::Unhealthy);
            statuses.insert(sandbox.sandbox_type(), status);
        }

        statuses
    }
}

/// æ²™ç®±ç®¡ç†å™¨é…ç½®
#[derive(Clone)]
pub struct SandboxManagerConfig {
    /// V8 æ²™ç®±é…ç½®
    pub v8_config: V8SandboxConfig,

    /// WASM æ²™ç®±é…ç½®
    pub wasm_config: Option<WasmSandboxConfig>,

    /// è¿œç¨‹æ²™ç®±é…ç½®
    pub remote_config: Option<RemoteSandboxConfig>,
}
```

---

## 3. V8 å®ç°

## 3. V8 å®ç°

### 3.1 V8Sandbox ç»“æ„

```rust
/// V8 æ²™ç®±å®ç°
pub struct V8Sandbox {
    /// Isolate æ± 
    isolate_pool: Arc<Mutex<VecDeque<v8::OwnedIsolate>>>,

    /// é…ç½®
    config: V8SandboxConfig,

    /// ç»Ÿè®¡ä¿¡æ¯
    stats: Arc<RwLock<SandboxStats>>,
}

#[async_trait]
impl CodeSandbox for V8Sandbox {
    fn sandbox_type(&self) -> SandboxType {
        SandboxType::V8
    }

    fn supported_languages(&self) -> Vec<CodeLanguage> {
        vec![CodeLanguage::JavaScript]
    }

    async fn execute(&self, request: SandboxRequest) -> Result<SandboxResult, SandboxError> {
        // éªŒè¯è¯­è¨€
        if request.language != CodeLanguage::JavaScript {
            return Err(SandboxError::UnsupportedLanguage(request.language));
        }

        // éªŒè¯ä»£ç 
        self.validate_code(&request.code)?;

        // è·å– Isolate
        let mut isolate = self.acquire_isolate().await?;

        // æ‰§è¡Œä»£ç 
        let start_time = Instant::now();
        let result = self.execute_in_isolate(&mut isolate, &request).await;
        let execution_time = start_time.elapsed();

        // å½’è¿˜ Isolate
        self.release_isolate(isolate).await;

        // æ›´æ–°ç»Ÿè®¡
        self.update_stats(&result, execution_time).await;

        result
    }

    async fn validate(&self, code: &str, language: CodeLanguage) -> Result<(), SandboxError> {
        if language != CodeLanguage::JavaScript {
            return Err(SandboxError::UnsupportedLanguage(language));
        }

        self.validate_code(code)
    }

    async fn health_check(&self) -> Result<HealthStatus, SandboxError> {
        // å°è¯•æ‰§è¡Œç®€å•ä»£ç 
        let request = SandboxRequest {
            code: "function main(inputs) { return { ok: true }; }".to_string(),
            language: CodeLanguage::JavaScript,
            inputs: json!({}),
            config: ExecutionConfig::default(),
        };

        match self.execute(request).await {
            Ok(_) => Ok(HealthStatus::Healthy),
            Err(_) => Ok(HealthStatus::Unhealthy),
        }
    }

    async fn get_stats(&self) -> Result<SandboxStats, SandboxError> {
        let stats = self.stats.read().await;
        Ok(stats.clone())
    }
}

impl V8Sandbox {
    pub fn new(config: V8SandboxConfig) -> Self {
        // åˆå§‹åŒ– V8
        let platform = v8::new_default_platform(0, false).make_shared();
        v8::V8::initialize_platform(platform);
        v8::V8::initialize();

        // åˆ›å»º Isolate æ± 
        let mut pool = VecDeque::new();
        for _ in 0..config.pool_size {
            pool.push_back(Self::create_isolate(&config));
        }

        Self {
            isolate_pool: Arc::new(Mutex::new(pool)),
            config,
            stats: Arc::new(RwLock::new(SandboxStats::default())),
        }
    }

    fn create_isolate(config: &V8SandboxConfig) -> v8::OwnedIsolate {
        let mut params = v8::CreateParams::default();
        params = params.heap_limits(0, config.max_heap_size);

        v8::Isolate::new(params)
    }

    async fn execute_in_isolate(
        &self,
        isolate: &mut v8::OwnedIsolate,
        request: &SandboxRequest,
    ) -> Result<SandboxResult, SandboxError> {
        let handle_scope = &mut v8::HandleScope::new(isolate);
        let context = v8::Context::new(handle_scope);
        let scope = &mut v8::ContextScope::new(handle_scope, context);

        // è®¾ç½®å®‰å…¨ç¯å¢ƒ
        self.setup_safe_globals(scope)?;

        // æ³¨å…¥è¾“å…¥
        self.inject_inputs(scope, &request.inputs)?;

        // ç¼–è¯‘ä»£ç 
        let script = self.compile_code(scope, &request.code)?;

        // æ‰§è¡Œä»£ç 
        let main_fn = self.run_script(scope, script)?;

        // è°ƒç”¨ main å‡½æ•°
        let output = self.call_main_function(scope, main_fn)?;

        // è½¬æ¢ç»“æœ
        let output_json = self.v8_value_to_json(scope, output)?;

        Ok(SandboxResult {
            success: true,
            output: output_json,
            stdout: String::new(),
            stderr: String::new(),
            execution_time: Duration::from_secs(0),  // åœ¨å¤–å±‚è®¡ç®—
            memory_used: 0,  // TODO: è·å–å®é™…å†…å­˜ä½¿ç”¨
            error: None,
        })
    }

    // ... å…¶ä»–è¾…åŠ©æ–¹æ³•
}

/// V8 æ²™ç®±é…ç½®
#[derive(Clone, Debug)]
pub struct V8SandboxConfig {
    /// æœ€å¤§å †å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
    pub max_heap_size: usize,

    /// Isolate æ± å¤§å°
    pub pool_size: usize,

    /// æ˜¯å¦å¯ç”¨å¿«ç…§
    pub enable_snapshot: bool,

    /// æ˜¯å¦å¯ç”¨ console
    pub enable_console: bool,

    /// æœ€å¤§ä»£ç é•¿åº¦
    pub max_code_length: usize,
}

impl Default for V8SandboxConfig {
    fn default() -> Self {
        Self {
            max_heap_size: 128 * 1024 * 1024,  // 128MB
            pool_size: 10,
            enable_snapshot: true,
            enable_console: true,
            max_code_length: 1_000_000,  // 1MB
        }
    }
}
```

### 3.2 æŠ€æœ¯é€‰å‹

| Crate | ç‰ˆæœ¬ | ç”¨é€” |
|-------|------|------|
| **rusty_v8** | 0.85 | V8 å¼•æ“ç»‘å®š |
| **serde_json** | 1.0 | JSON åºåˆ—åŒ– |
| **tokio** | 1.35 | å¼‚æ­¥è¿è¡Œæ—¶ |

---

## 4. å…¶ä»–å®ç°æ–¹æ¡ˆï¼ˆæ¥å£é¢„ç•™ï¼‰

### 4.1 è®¾è®¡è¯´æ˜

é€šè¿‡ `CodeSandbox` traitï¼Œç³»ç»Ÿé¢„ç•™äº†æ‰©å±•å…¶ä»–æ²™ç®±å®ç°çš„èƒ½åŠ›ã€‚æœªæ¥å¯ä»¥æ ¹æ®éœ€æ±‚å®ç°ï¼š

- **WebAssembly æ²™ç®±**: ä½¿ç”¨ wasmtime æˆ– wasmer æ‰§è¡Œ WASM äºŒè¿›åˆ¶ä»£ç 
- **è¿œç¨‹æ²™ç®±æœåŠ¡**: é€šè¿‡ HTTP/gRPC è°ƒç”¨å¤–éƒ¨æ²™ç®±æœåŠ¡ï¼Œæ”¯æŒ Pythonã€Ruby ç­‰å¤šç§è¯­è¨€
- **å…¶ä»–è¯­è¨€è§£é‡Šå™¨**: åµŒå…¥ Pythonã€Lua ç­‰è§£é‡Šå™¨

### 4.2 å®ç°æ¥å£

ä»»ä½•æ–°çš„æ²™ç®±å®ç°åªéœ€å®ç° `CodeSandbox` traitï¼š

```rust
pub struct CustomSandbox {
    // è‡ªå®šä¹‰é…ç½®å’ŒçŠ¶æ€
}

#[async_trait]
impl CodeSandbox for CustomSandbox {
    fn sandbox_type(&self) -> SandboxType {
        SandboxType::Custom  // éœ€è¦æ‰©å±• SandboxType æšä¸¾
    }

    fn supported_languages(&self) -> Vec<CodeLanguage> {
        vec![CodeLanguage::Custom]  // éœ€è¦æ‰©å±• CodeLanguage æšä¸¾
    }

    async fn execute(&self, request: SandboxRequest) -> Result<SandboxResult, SandboxError> {
        // å®ç°å…·ä½“çš„æ‰§è¡Œé€»è¾‘
        todo!("Implement custom sandbox execution")
    }

    async fn validate(&self, code: &str, language: CodeLanguage) -> Result<(), SandboxError> {
        // å¯é€‰ï¼šå®ç°ä»£ç éªŒè¯
        Ok(())
    }

    async fn health_check(&self) -> Result<HealthStatus, SandboxError> {
        // å¯é€‰ï¼šå®ç°å¥åº·æ£€æŸ¥
        Ok(HealthStatus::Healthy)
    }

    async fn get_stats(&self) -> Result<SandboxStats, SandboxError> {
        // å¯é€‰ï¼šè¿”å›ç»Ÿè®¡ä¿¡æ¯
        Ok(SandboxStats::default())
    }
}
```

### 4.3 æ³¨å†Œä½¿ç”¨

```rust
// åˆ›å»ºè‡ªå®šä¹‰æ²™ç®±å®ä¾‹
let custom_sandbox = CustomSandbox::new(config);

// æ³¨å†Œåˆ°ç®¡ç†å™¨
manager.register_sandbox(
    CodeLanguage::Custom,
    Arc::new(custom_sandbox)
);

// ä½¿ç”¨æ—¶ä¼šè‡ªåŠ¨é€‰æ‹©
let result = manager.execute(SandboxRequest {
    language: CodeLanguage::Custom,
    // ...
}).await?;
```

### 4.4 æ‰©å±•å»ºè®®

**WebAssembly æ²™ç®±**:
- æ¨èä½¿ç”¨ `wasmtime` crate
- æä¾›æè‡´æ€§èƒ½å’Œå®‰å…¨éš”ç¦»
- é€‚åˆè¿è¡Œç¼–è¯‘åçš„äºŒè¿›åˆ¶ä»£ç 

**è¿œç¨‹æ²™ç®±æœåŠ¡**:
- ä½¿ç”¨ `reqwest` æˆ– `tonic` (gRPC) è°ƒç”¨å¤–éƒ¨æœåŠ¡
- æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€ï¼ˆPythonã€Rubyã€Go ç­‰ï¼‰
- é€‚åˆéœ€è¦èµ„æºéš”ç¦»æˆ–å¤šè¯­è¨€æ”¯æŒçš„åœºæ™¯

**Python/Lua è§£é‡Šå™¨**:
- ä½¿ç”¨ `pyo3` åµŒå…¥ Python è§£é‡Šå™¨
- ä½¿ç”¨ `mlua` åµŒå…¥ Lua è§£é‡Šå™¨
- æ³¨æ„å®‰å…¨éš”ç¦»å’Œèµ„æºé™åˆ¶

### 4.5 å®ç°å¯¹æ¯”

| å®ç°ç±»å‹ | æ€§èƒ½ | å»¶è¿Ÿ | è¯­è¨€æ”¯æŒ | èµ„æºéš”ç¦» | å®ç°å¤æ‚åº¦ |
|---------|------|------|---------|---------|-----------|
| **V8 (é»˜è®¤)** | â­â­â­â­â­ | < 1ms | JS | â­â­â­â­ | ä¸­ |
| **WASM (é¢„ç•™)** | â­â­â­â­â­ | < 1ms | WASM | â­â­â­â­â­ | ä¸­ |
| **è¿œç¨‹ (é¢„ç•™)** | â­â­â­ | 10-50ms | å¤šè¯­è¨€ | â­â­â­â­â­ | ä½ |
| **åµŒå…¥å¼ (é¢„ç•™)** | â­â­â­â­ | 1-5ms | å•è¯­è¨€ | â­â­â­ | é«˜ |

---

## 5. æ¶æ„è®¾è®¡

| Crate | ä¼˜åŠ¿ | åŠ£åŠ¿ | æ¨èåº¦ |
|-------|------|------|--------|
| **rusty_v8** | â€¢ Deno å®˜æ–¹ä½¿ç”¨<br>â€¢ ç»´æŠ¤æ´»è·ƒ<br>â€¢ åŠŸèƒ½å®Œæ•´<br>â€¢ æ–‡æ¡£ä¸°å¯Œ | â€¢ ç¼–è¯‘æ—¶é—´é•¿<br>â€¢ äºŒè¿›åˆ¶ä½“ç§¯å¤§ | â­â­â­â­â­ |
| **v8** (old) | â€¢ ç®€å•æ˜“ç”¨ | â€¢ å·²åœæ­¢ç»´æŠ¤<br>â€¢ åŠŸèƒ½æœ‰é™ | â­â­ |
| **deno_core** | â€¢ é«˜çº§æŠ½è±¡<br>â€¢ åŒ…å«è¿è¡Œæ—¶ | â€¢ è¿‡äºå¤æ‚<br>â€¢ ä¾èµ–å¤š | â­â­â­ |

**æœ€ç»ˆé€‰æ‹©**: **rusty_v8**

**ç†ç”±**:
- Deno é¡¹ç›®çš„æ ¸å¿ƒä¾èµ–ï¼Œç»è¿‡å¤§è§„æ¨¡ç”Ÿäº§éªŒè¯
- æä¾›å®Œæ•´çš„ V8 API ç»‘å®š
- æ´»è·ƒçš„ç¤¾åŒºå’ŒæŒç»­æ›´æ–°
- æ”¯æŒå¿«ç…§ï¼ˆSnapshotï¼‰ä¼˜åŒ–å¯åŠ¨é€Ÿåº¦

### 2.2 ä¾èµ–é…ç½®

```toml
[dependencies]
# V8 å¼•æ“ç»‘å®š
rusty_v8 = "0.85"

# ç”¨äºåºåˆ—åŒ–/ååºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# å¼‚æ­¥æ”¯æŒ
tokio = { version = "1.35", features = ["full"] }
```

---

## 3. æ¶æ„è®¾è®¡

## 5. æ¶æ„è®¾è®¡

### 5.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Code Node Executor                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Sandbox Manager                               â”‚  â”‚
â”‚  â”‚  â€¢ ç®¡ç†å¤šä¸ªæ²™ç®±å®ç°                                    â”‚  â”‚
â”‚  â”‚  â€¢ æ ¹æ®è¯­è¨€é€‰æ‹©åˆé€‚çš„æ²™ç®±                              â”‚  â”‚
â”‚  â”‚  â€¢ ç»Ÿä¸€çš„ç›‘æ§å’Œæ—¥å¿—                                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         CodeSandbox Trait (ç»Ÿä¸€æ¥å£)                  â”‚  â”‚
â”‚  â”‚  â€¢ execute(request) -> Result                         â”‚  â”‚
â”‚  â”‚  â€¢ validate(code, language) -> Result                 â”‚  â”‚
â”‚  â”‚  â€¢ health_check() -> HealthStatus                     â”‚  â”‚
â”‚  â”‚  â€¢ get_stats() -> SandboxStats                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚              â”‚              â”‚                      â”‚    â”‚
â”‚  â–¼              â–¼              â–¼                      â–¼    â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚V8      â”‚  â”‚WASM    â”‚  â”‚Remote      â”‚  â”‚Future        â”‚  â”‚
â”‚ â”‚Sandbox â”‚  â”‚Sandbox â”‚  â”‚Sandbox     â”‚  â”‚Implementationsâ”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚     â”‚            â”‚            â”‚                â”‚           â”‚
â”‚     â–¼            â–¼            â–¼                â–¼           â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚V8      â”‚  â”‚Wasmtimeâ”‚  â”‚HTTP/gRPC   â”‚  â”‚Python/Lua    â”‚  â”‚
â”‚ â”‚Engine  â”‚  â”‚Engine  â”‚  â”‚Client      â”‚  â”‚Interpreters  â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 æ‰§è¡Œæµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Code Node æ¥æ”¶æ‰§è¡Œè¯·æ±‚                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. æ„å»º SandboxRequest                                       â”‚
â”‚    â€¢ code: ç”¨æˆ·ä»£ç                                           â”‚
â”‚    â€¢ language: JavaScript/Python/WASM                        â”‚
â”‚    â€¢ inputs: è¾“å…¥æ•°æ®                                        â”‚
â”‚    â€¢ config: æ‰§è¡Œé…ç½®ï¼ˆè¶…æ—¶ã€å†…å­˜é™åˆ¶ç­‰ï¼‰                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. SandboxManager é€‰æ‹©åˆé€‚çš„æ²™ç®±                             â”‚
â”‚    â€¢ æ ¹æ® language æŸ¥æ‰¾æ³¨å†Œçš„æ²™ç®±                            â”‚
â”‚    â€¢ å¦‚æœæ²¡æœ‰ï¼Œä½¿ç”¨é»˜è®¤æ²™ç®±ï¼ˆV8ï¼‰                             â”‚
â”‚    â€¢ éªŒè¯æ²™ç®±æ˜¯å¦æ”¯æŒè¯¥è¯­è¨€                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. è°ƒç”¨ sandbox.execute(request)                            â”‚
â”‚    â€¢ V8: ä»æ± ä¸­è·å– Isolate â†’ æ‰§è¡Œ â†’ å½’è¿˜                    â”‚
â”‚    â€¢ WASM: ç¼–è¯‘æ¨¡å— â†’ å®ä¾‹åŒ– â†’ è°ƒç”¨å‡½æ•°                      â”‚
â”‚    â€¢ Remote: å‘é€ HTTP è¯·æ±‚ â†’ ç­‰å¾…å“åº”                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. è¿”å› SandboxResult                                        â”‚
â”‚    â€¢ success: æ˜¯å¦æˆåŠŸ                                       â”‚
â”‚    â€¢ output: è¾“å‡ºæ•°æ®ï¼ˆJSONï¼‰                                â”‚
â”‚    â€¢ stdout/stderr: æ ‡å‡†è¾“å‡º/é”™è¯¯                            â”‚
â”‚    â€¢ execution_time: æ‰§è¡Œæ—¶é—´                                â”‚
â”‚    â€¢ memory_used: å†…å­˜ä½¿ç”¨                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. Code Node å¤„ç†ç»“æœ                                        â”‚
â”‚    â€¢ å°† output å†™å…¥ VariablePool                             â”‚
â”‚    â€¢ è®°å½•æ‰§è¡Œæ—¥å¿—                                            â”‚
â”‚    â€¢ å‘é€æŒä¹…åŒ–äº‹ä»¶                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.3 å¤šæ²™ç®±é…ç½®ç¤ºä¾‹

```rust
// åˆ›å»ºæ²™ç®±ç®¡ç†å™¨ï¼ˆé»˜è®¤åªæœ‰ V8ï¼‰
let manager = SandboxManager::new(SandboxManagerConfig {
    v8_config: V8SandboxConfig::default(),
    wasm_config: None,    // æœªæ¥æ‰©å±•
    remote_config: None,  // æœªæ¥æ‰©å±•
});

// æ‰§è¡Œ JavaScriptï¼ˆä½¿ç”¨ V8ï¼‰
let result = manager.execute(SandboxRequest {
    code: "function main(inputs) { return { result: inputs.value * 2 }; }".to_string(),
    language: CodeLanguage::JavaScript,
    inputs: json!({ "value": 42 }),
    config: ExecutionConfig::default(),
}).await?;

// æœªæ¥å¯ä»¥è¿™æ ·æ‰©å±•ï¼š
// manager.register_sandbox(CodeLanguage::Python, Arc::new(PythonSandbox::new()));
// manager.register_sandbox(CodeLanguage::Wasm, Arc::new(WasmSandbox::new()));
```

---

## 6. å®‰å…¨æœºåˆ¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Code Node Executor                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         V8 Sandbox Manager                        â”‚  â”‚
â”‚  â”‚  â€¢ Isolate Pool (å¤ç”¨ V8 Isolate)                â”‚  â”‚
â”‚  â”‚  â€¢ Context Management                             â”‚  â”‚
â”‚  â”‚  â€¢ Resource Limits                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                          â†“                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         V8 Sandbox Instance                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  V8 Isolate (ç‹¬ç«‹çš„ JS æ‰§è¡Œç¯å¢ƒ)            â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  V8 Context (å…¨å±€å¯¹è±¡å’Œä½œç”¨åŸŸ)        â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  User JavaScript Code           â”‚  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  â€¢ ç”¨æˆ·å®šä¹‰çš„ main å‡½æ•°          â”‚  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â”‚  â€¢ æ•°æ®å¤„ç†é€»è¾‘                  â”‚  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚                                       â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  Safe APIs (ç™½åå•)                  â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ JSON.parse/stringify              â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ Array/Object methods              â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ Math functions                    â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”‚  â€¢ String operations                 â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚                                             â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  Blocked APIs (é»‘åå•)                      â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  âœ— require/import                           â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  âœ— process/global                           â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  âœ— setTimeout/setInterval                   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  âœ— fetch/XMLHttpRequest                     â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  âœ— eval/Function constructor                â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                   â”‚  â”‚
â”‚  â”‚  Resource Monitors                                â”‚  â”‚
â”‚  â”‚  â€¢ Memory Limit: 128MB                            â”‚  â”‚
â”‚  â”‚  â€¢ Execution Timeout: 30s                         â”‚  â”‚
â”‚  â”‚  â€¢ Stack Depth: 100                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ ¸å¿ƒç»„ä»¶

#### 3.2.1 V8SandboxManager

èŒè´£ï¼šç®¡ç† V8 Isolate æ± å’Œç”Ÿå‘½å‘¨æœŸ

```rust
pub struct V8SandboxManager {
    /// Isolate æ± ï¼ˆå¤ç”¨ä»¥æé«˜æ€§èƒ½ï¼‰
    isolate_pool: Arc<Mutex<Vec<V8Isolate>>>,

    /// é…ç½®
    config: SandboxConfig,

    /// ç»Ÿè®¡ä¿¡æ¯
    stats: Arc<RwLock<SandboxStats>>,
}
```

#### 3.2.2 V8Sandbox

èŒè´£ï¼šå•ä¸ªæ²™ç®±å®ä¾‹ï¼Œæ‰§è¡Œ JavaScript ä»£ç 

```rust
pub struct V8Sandbox {
    /// V8 Isolateï¼ˆç‹¬ç«‹çš„ JS è™šæ‹Ÿæœºï¼‰
    isolate: v8::OwnedIsolate,

    /// èµ„æºé™åˆ¶
    limits: ResourceLimits,

    /// æ‰§è¡Œè¶…æ—¶
    timeout: Duration,
}
```

#### 3.2.3 SandboxConfig

èŒè´£ï¼šæ²™ç®±é…ç½®

```rust
pub struct SandboxConfig {
    /// æœ€å¤§å †å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
    pub max_heap_size: usize,

    /// æ‰§è¡Œè¶…æ—¶ï¼ˆç§’ï¼‰
    pub execution_timeout: Duration,

    /// æœ€å¤§æ ˆæ·±åº¦
    pub max_stack_depth: usize,

    /// æ˜¯å¦å¯ç”¨ Isolate æ± 
    pub enable_isolate_pool: bool,

    /// æ± å¤§å°
    pub pool_size: usize,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            max_heap_size: 128 * 1024 * 1024,  // 128MB
            execution_timeout: Duration::from_secs(30),
            max_stack_depth: 100,
            enable_isolate_pool: true,
            pool_size: 10,
        }
    }
}
```

---

## 4. å®‰å…¨æœºåˆ¶

### 4.1 éš”ç¦»å±‚çº§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Level 1: Process Isolation            â”‚
â”‚  â€¢ V8 è¿è¡Œåœ¨ Rust è¿›ç¨‹å†…                â”‚
â”‚  â€¢ ä¸ä¸»çº¿ç¨‹éš”ç¦»ï¼ˆç‹¬ç«‹çº¿ç¨‹æ± ï¼‰            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Level 2: V8 Isolate Isolation          â”‚
â”‚  â€¢ æ¯ä¸ªæ‰§è¡Œä½¿ç”¨ç‹¬ç«‹çš„ Isolate            â”‚
â”‚  â€¢ å†…å­˜å®Œå…¨éš”ç¦»                          â”‚
â”‚  â€¢ æ— æ³•è®¿é—®å…¶ä»– Isolate çš„æ•°æ®           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Level 3: Context Isolation             â”‚
â”‚  â€¢ æ¯ä¸ªæ‰§è¡Œåˆ›å»ºæ–°çš„ Context              â”‚
â”‚  â€¢ å…¨å±€å¯¹è±¡ç‹¬ç«‹                          â”‚
â”‚  â€¢ åŸå‹é“¾éš”ç¦»                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Level 4: API Whitelist                 â”‚
â”‚  â€¢ åªæš´éœ²å®‰å…¨çš„ API                      â”‚
â”‚  â€¢ å±é™© API å®Œå…¨ä¸å¯è®¿é—®                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 API ç™½åå•

**å…è®¸çš„å…¨å±€å¯¹è±¡**:
```javascript
// åŸºç¡€å¯¹è±¡
Object, Array, String, Number, Boolean, Date, Math, JSON

// é”™è¯¯ç±»å‹
Error, TypeError, RangeError, SyntaxError

// å·¥å…·å‡½æ•°
parseInt, parseFloat, isNaN, isFinite

// æ•°ç»„æ–¹æ³•
Array.prototype.map, filter, reduce, forEach, find, some, every

// å­—ç¬¦ä¸²æ–¹æ³•
String.prototype.split, join, slice, substring, indexOf, replace

// å¯¹è±¡æ–¹æ³•
Object.keys, values, entries, assign, freeze
```

**ç¦æ­¢çš„å…¨å±€å¯¹è±¡**:
```javascript
// æ¨¡å—ç³»ç»Ÿ
require, import, export

// è¿›ç¨‹å’Œå…¨å±€
process, global, globalThis.__proto__

// å®šæ—¶å™¨
setTimeout, setInterval, setImmediate

// ç½‘ç»œ
fetch, XMLHttpRequest, WebSocket

// æ–‡ä»¶ç³»ç»Ÿ
fs, path, os

// åŠ¨æ€ä»£ç æ‰§è¡Œ
eval, Function, GeneratorFunction, AsyncFunction

// è°ƒè¯•
debugger, console (éƒ¨åˆ†é™åˆ¶)
```

### 4.3 èµ„æºé™åˆ¶

#### 4.3.1 å†…å­˜é™åˆ¶

```rust
impl V8Sandbox {
    fn set_memory_limit(&mut self, max_bytes: usize) {
        // è®¾ç½®å †å†…å­˜é™åˆ¶
        self.isolate.set_heap_limit(max_bytes);

        // è®¾ç½®å¤–éƒ¨å†…å­˜é™åˆ¶
        self.isolate.set_external_memory_limit(max_bytes / 2);
    }

    fn check_memory_usage(&self) -> Result<(), SandboxError> {
        let stats = self.isolate.get_heap_statistics();

        if stats.used_heap_size() > self.limits.max_heap_size {
            return Err(SandboxError::MemoryLimitExceeded);
        }

        Ok(())
    }
}
```

#### 4.3.2 æ‰§è¡Œè¶…æ—¶

```rust
impl V8Sandbox {
    pub async fn execute_with_timeout(
        &mut self,
        code: &str,
        timeout: Duration,
    ) -> Result<v8::Global<v8::Value>, SandboxError> {
        // ä½¿ç”¨ tokio::time::timeout åŒ…è£…æ‰§è¡Œ
        tokio::time::timeout(timeout, async {
            self.execute(code).await
        })
        .await
        .map_err(|_| SandboxError::ExecutionTimeout)?
    }
}
```

#### 4.3.3 æ ˆæ·±åº¦é™åˆ¶

```rust
// åœ¨ V8 Context ä¸­è®¾ç½®æ ˆå¤§å°
fn create_context_with_stack_limit(
    isolate: &mut v8::Isolate,
    stack_size: usize,
) -> v8::Local<v8::Context> {
    // V8 ä¼šè‡ªåŠ¨æ£€æµ‹æ ˆæº¢å‡º
    // é€šè¿‡ RangeError: Maximum call stack size exceeded
    v8::Context::new(isolate)
}
```

### 4.4 ä»£ç æ³¨å…¥é˜²æŠ¤

```rust
impl V8Sandbox {
    /// éªŒè¯ç”¨æˆ·ä»£ç ï¼Œé˜²æ­¢æ¶æ„æ³¨å…¥
    fn validate_code(&self, code: &str) -> Result<(), SandboxError> {
        // 1. æ£€æŸ¥ä»£ç é•¿åº¦
        if code.len() > 1_000_000 {  // 1MB
            return Err(SandboxError::CodeTooLarge);
        }

        // 2. æ£€æŸ¥å±é™©æ¨¡å¼
        let dangerous_patterns = [
            r"__proto__",
            r"constructor\s*\[",
            r"eval\s*\(",
            r"Function\s*\(",
            r"require\s*\(",
            r"import\s+",
        ];

        for pattern in &dangerous_patterns {
            if regex::Regex::new(pattern).unwrap().is_match(code) {
                return Err(SandboxError::DangerousCode(pattern.to_string()));
            }
        }

        Ok(())
    }
}
```

---

## 5. API è®¾è®¡

### 5.1 å…¬å…±æ¥å£

```rust
/// V8 æ²™ç®±ç®¡ç†å™¨
pub struct V8SandboxManager {
    config: SandboxConfig,
    isolate_pool: Arc<Mutex<Vec<V8Isolate>>>,
}

impl V8SandboxManager {
    /// åˆ›å»ºæ–°çš„æ²™ç®±ç®¡ç†å™¨
    pub fn new(config: SandboxConfig) -> Self {
        // åˆå§‹åŒ– V8 å¹³å°
        v8::V8::initialize_platform(
            v8::new_default_platform(0, false).make_shared()
        );
        v8::V8::initialize();

        Self {
            config,
            isolate_pool: Arc::new(Mutex::new(Vec::new())),
        }
    }

    /// æ‰§è¡Œ JavaScript ä»£ç 
    pub async fn execute(
        &self,
        code: &str,
        inputs: serde_json::Value,
    ) -> Result<serde_json::Value, SandboxError> {
        // 1. ä»æ± ä¸­è·å–æˆ–åˆ›å»º Isolate
        let mut sandbox = self.acquire_sandbox().await?;

        // 2. éªŒè¯ä»£ç 
        sandbox.validate_code(code)?;

        // 3. æ‰§è¡Œä»£ç 
        let result = sandbox.execute_with_inputs(code, inputs).await?;

        // 4. å½’è¿˜ Isolate åˆ°æ± 
        self.release_sandbox(sandbox).await;

        Ok(result)
    }

    /// ä»æ± ä¸­è·å–æ²™ç®±
    async fn acquire_sandbox(&self) -> Result<V8Sandbox, SandboxError> {
        let mut pool = self.isolate_pool.lock().await;

        if let Some(isolate) = pool.pop() {
            Ok(V8Sandbox::from_isolate(isolate, self.config.clone()))
        } else {
            Ok(V8Sandbox::new(self.config.clone()))
        }
    }

    /// å½’è¿˜æ²™ç®±åˆ°æ± 
    async fn release_sandbox(&self, sandbox: V8Sandbox) {
        if self.config.enable_isolate_pool {
            let mut pool = self.isolate_pool.lock().await;

            if pool.len() < self.config.pool_size {
                pool.push(sandbox.into_isolate());
            }
        }
    }
}

/// V8 æ²™ç®±å®ä¾‹
pub struct V8Sandbox {
    isolate: v8::OwnedIsolate,
    config: SandboxConfig,
}

impl V8Sandbox {
    /// åˆ›å»ºæ–°çš„æ²™ç®±
    pub fn new(config: SandboxConfig) -> Self {
        let mut isolate = v8::Isolate::new(v8::CreateParams::default());

        // è®¾ç½®å†…å­˜é™åˆ¶
        isolate.set_heap_limit(config.max_heap_size);

        Self { isolate, config }
    }

    /// æ‰§è¡Œä»£ç å¹¶ä¼ å…¥è¾“å…¥
    pub async fn execute_with_inputs(
        &mut self,
        code: &str,
        inputs: serde_json::Value,
    ) -> Result<serde_json::Value, SandboxError> {
        let handle_scope = &mut v8::HandleScope::new(&mut self.isolate);
        let context = v8::Context::new(handle_scope);
        let scope = &mut v8::ContextScope::new(handle_scope, context);

        // 1. åˆ›å»ºå®‰å…¨çš„å…¨å±€å¯¹è±¡
        self.setup_safe_globals(scope)?;

        // 2. æ³¨å…¥è¾“å…¥æ•°æ®
        self.inject_inputs(scope, inputs)?;

        // 3. ç¼–è¯‘ç”¨æˆ·ä»£ç 
        let script = self.compile_code(scope, code)?;

        // 4. æ‰§è¡Œä»£ç 
        let result = self.run_script(scope, script)?;

        // 5. è°ƒç”¨ main å‡½æ•°
        let output = self.call_main_function(scope, result)?;

        // 6. è½¬æ¢ç»“æœä¸º JSON
        self.v8_value_to_json(scope, output)
    }

    /// è®¾ç½®å®‰å…¨çš„å…¨å±€å¯¹è±¡
    fn setup_safe_globals(
        &self,
        scope: &mut v8::HandleScope,
    ) -> Result<(), SandboxError> {
        let global = scope.get_current_context().global(scope);

        // åˆ é™¤å±é™©çš„å…¨å±€å¯¹è±¡
        let dangerous_globals = [
            "require", "import", "eval", "Function",
            "setTimeout", "setInterval", "setImmediate",
            "process", "global", "globalThis",
        ];

        for name in &dangerous_globals {
            let key = v8::String::new(scope, name).unwrap();
            global.delete(scope, key.into());
        }

        // æ·»åŠ å®‰å…¨çš„ consoleï¼ˆä»… logï¼‰
        self.setup_safe_console(scope, global)?;

        Ok(())
    }

    /// æ³¨å…¥è¾“å…¥æ•°æ®
    fn inject_inputs(
        &self,
        scope: &mut v8::HandleScope,
        inputs: serde_json::Value,
    ) -> Result<(), SandboxError> {
        let global = scope.get_current_context().global(scope);

        // å°† JSON è½¬æ¢ä¸º V8 å€¼
        let inputs_v8 = self.json_to_v8_value(scope, inputs)?;

        // è®¾ç½®ä¸ºå…¨å±€å˜é‡ __inputs__
        let key = v8::String::new(scope, "__inputs__").unwrap();
        global.set(scope, key.into(), inputs_v8);

        Ok(())
    }

    /// ç¼–è¯‘ä»£ç 
    fn compile_code(
        &self,
        scope: &mut v8::HandleScope,
        code: &str,
    ) -> Result<v8::Local<v8::Script>, SandboxError> {
        // åŒ…è£…ç”¨æˆ·ä»£ç 
        let wrapped_code = format!(
            r#"
            (function() {{
                {}

                // ç¡®ä¿ main å‡½æ•°å­˜åœ¨
                if (typeof main !== 'function') {{
                    throw new Error('main function is not defined');
                }}

                return main;
            }})();
            "#,
            code
        );

        let code_v8 = v8::String::new(scope, &wrapped_code).unwrap();

        v8::Script::compile(scope, code_v8, None)
            .ok_or(SandboxError::CompilationError)
    }

    /// è¿è¡Œè„šæœ¬
    fn run_script(
        &self,
        scope: &mut v8::HandleScope,
        script: v8::Local<v8::Script>,
    ) -> Result<v8::Local<v8::Value>, SandboxError> {
        script.run(scope)
            .ok_or(SandboxError::ExecutionError("Script execution failed".to_string()))
    }

    /// è°ƒç”¨ main å‡½æ•°
    fn call_main_function(
        &self,
        scope: &mut v8::HandleScope,
        main_fn: v8::Local<v8::Value>,
    ) -> Result<v8::Local<v8::Value>, SandboxError> {
        let main_fn = v8::Local::<v8::Function>::try_from(main_fn)
            .map_err(|_| SandboxError::TypeError("main is not a function".to_string()))?;

        let global = scope.get_current_context().global(scope);

        // è·å–è¾“å…¥
        let inputs_key = v8::String::new(scope, "__inputs__").unwrap();
        let inputs = global.get(scope, inputs_key.into()).unwrap();

        // è°ƒç”¨ main(inputs)
        let result = main_fn.call(scope, global.into(), &[inputs])
            .ok_or(SandboxError::ExecutionError("main function call failed".to_string()))?;

        Ok(result)
    }

    /// V8 å€¼è½¬ JSON
    fn v8_value_to_json(
        &self,
        scope: &mut v8::HandleScope,
        value: v8::Local<v8::Value>,
    ) -> Result<serde_json::Value, SandboxError> {
        let json_string = v8::json::stringify(scope, value)
            .ok_or(SandboxError::SerializationError)?;

        let rust_string = json_string.to_rust_string_lossy(scope);

        serde_json::from_str(&rust_string)
            .map_err(|e| SandboxError::SerializationError)
    }

    /// JSON è½¬ V8 å€¼
    fn json_to_v8_value(
        &self,
        scope: &mut v8::HandleScope,
        json: serde_json::Value,
    ) -> Result<v8::Local<v8::Value>, SandboxError> {
        let json_string = serde_json::to_string(&json)
            .map_err(|_| SandboxError::SerializationError)?;

        let v8_string = v8::String::new(scope, &json_string).unwrap();

        v8::json::parse(scope, v8_string)
            .ok_or(SandboxError::SerializationError)
    }
}
```

### 5.2 é”™è¯¯ç±»å‹

```rust
#[derive(Debug, thiserror::Error)]
pub enum SandboxError {
    #[error("Code too large (max 1MB)")]
    CodeTooLarge,

    #[error("Dangerous code detected: {0}")]
    DangerousCode(String),

    #[error("Compilation error")]
    CompilationError,

    #[error("Execution error: {0}")]
    ExecutionError(String),

    #[error("Type error: {0}")]
    TypeError(String),

    #[error("Memory limit exceeded")]
    MemoryLimitExceeded,

    #[error("Execution timeout")]
    ExecutionTimeout,

    #[error("Serialization error")]
    SerializationError,

    #[error("V8 initialization error")]
    InitializationError,
}
```

---

## 6. å®ç°ç»†èŠ‚

### 8.1 Code èŠ‚ç‚¹é›†æˆ

```rust
// src/nodes/data_transform/code.rs

use crate::sandbox::{
    CodeSandbox, SandboxManager, SandboxRequest, CodeLanguage, ExecutionConfig
};

pub struct CodeNodeExecutor {
    sandbox_manager: Arc<SandboxManager>,
}

impl CodeNodeExecutor {
    pub fn new() -> Self {
        // åˆ›å»ºæ²™ç®±ç®¡ç†å™¨
        let mut manager = SandboxManager::new(SandboxManagerConfig {
            v8_config: V8SandboxConfig::default(),
            wasm_config: None,  // å¯é€‰
            remote_config: None,  // å¯é€‰
        });

        // å¯ä»¥æ³¨å†Œé¢å¤–çš„æ²™ç®±å®ç°
        // manager.register_sandbox(CodeLanguage::Python, ...);

        Self {
            sandbox_manager: Arc::new(manager),
        }
    }
}

#[async_trait]
impl NodeExecutor for CodeNodeExecutor {
    fn validate(&self, config: &Value) -> Result<(), NodeError> {
        let config: CodeNodeConfig = serde_json::from_value(config.clone())?;

        // éªŒè¯ä»£ç ä¸ä¸ºç©º
        if config.code.trim().is_empty() {
            return Err(NodeError::ConfigError(
                "Code cannot be empty".to_string()
            ));
        }

        // éªŒè¯è¯­è¨€æ˜¯å¦æ”¯æŒ
        // è¿™é‡Œå¯ä»¥è°ƒç”¨ sandbox_manager æ£€æŸ¥

        Ok(())
    }

    async fn execute(
        &self,
        ctx: &NodeContext,
        pool: &Arc<RwLock<VariablePool>>,
        event_sender: &EventSender,
    ) -> Result<NodeExecutionResult, NodeError> {
        let config: CodeNodeConfig = serde_json::from_value(ctx.config.clone())?;

        // 1. ä»å˜é‡æ± è¯»å–è¾“å…¥
        let pool_read = pool.read().await;
        let mut inputs = json!({});

        for (var_name, var_selector) in &config.inputs {
            if let Some(value) = pool_read.get_value(var_selector) {
                inputs[var_name] = value;
            }
        }
        drop(pool_read);

        // 2. æ„å»ºæ²™ç®±è¯·æ±‚
        let request = SandboxRequest {
            code: config.code.clone(),
            language: config.language,
            inputs,
            config: ExecutionConfig {
                timeout: Duration::from_secs(config.timeout.unwrap_or(30)),
                max_memory: config.max_memory.unwrap_or(128 * 1024 * 1024),
                max_cpu_time: None,
                env_vars: HashMap::new(),
            },
        };

        // 3. æ‰§è¡Œä»£ç ï¼ˆè‡ªåŠ¨é€‰æ‹©åˆé€‚çš„æ²™ç®±ï¼‰
        let result = self.sandbox_manager
            .execute(request)
            .await
            .map_err(|e| NodeError::ExecutionError(e.to_string()))?;

        // 4. æ£€æŸ¥æ‰§è¡Œç»“æœ
        if !result.success {
            return Err(NodeError::ExecutionError(
                result.error.unwrap_or_else(|| "Unknown error".to_string())
            ));
        }

        // 5. è¿”å›ç»“æœ
        Ok(NodeExecutionResult::Completed(json!({
            config.output_variable: result.output,
            "_execution_time_ms": result.execution_time.as_millis(),
            "_memory_used_bytes": result.memory_used,
        })))
    }

    fn node_type(&self) -> &str {
        "code"
    }
}

/// Code èŠ‚ç‚¹é…ç½®
#[derive(Deserialize, Serialize, Debug)]
pub struct CodeNodeConfig {
    /// ç¼–ç¨‹è¯­è¨€
    pub language: CodeLanguage,

    /// ä»£ç å†…å®¹
    pub code: String,

    /// è¾“å…¥å˜é‡æ˜ å°„
    pub inputs: HashMap<String, String>,

    /// è¾“å‡ºå˜é‡å
    pub output_variable: String,

    /// æ‰§è¡Œè¶…æ—¶ï¼ˆç§’ï¼‰
    #[serde(default)]
    pub timeout: Option<u64>,

    /// æœ€å¤§å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
    #[serde(default)]
    pub max_memory: Option<usize>,
}
```

### 8.2 DSL é…ç½®ç¤ºä¾‹

```yaml
# JavaScript ä»£ç èŠ‚ç‚¹ï¼ˆä½¿ç”¨ V8ï¼‰
- id: code_js
  type: code
  data:
    language: javascript
    code: |
      function main(inputs) {
          const { numbers } = inputs;
          const sum = numbers.reduce((a, b) => a + b, 0);
          const avg = sum / numbers.length;
          return { sum, avg };
      }
    inputs:
      numbers: "input.numbers"
    output_variable: "stats"
    timeout: 30
    max_memory: 134217728  # 128MB

# Python ä»£ç èŠ‚ç‚¹ï¼ˆä½¿ç”¨è¿œç¨‹æ²™ç®±ï¼‰
- id: code_py
  type: code
  data:
    language: python
    code: |
      def main(inputs):
          numbers = inputs['numbers']
          total = sum(numbers)
          avg = total / len(numbers)
          return {'sum': total, 'avg': avg}
    inputs:
      numbers: "input.numbers"
    output_variable: "stats"
    timeout: 30

# WASM ä»£ç èŠ‚ç‚¹ï¼ˆä½¿ç”¨ WASM æ²™ç®±ï¼‰
- id: code_wasm
  type: code
  data:
    language: wasm
    code: "<base64-encoded-wasm-binary>"
    inputs:
      value: "input.value"
    output_variable: "result"
```

### 8.3 æ²™ç®±åˆ‡æ¢ç­–ç•¥

```rust
/// æ²™ç®±é€‰æ‹©ç­–ç•¥
pub enum SandboxSelectionStrategy {
    /// æŒ‰è¯­è¨€é€‰æ‹©
    ByLanguage,

    /// æŒ‰æ€§èƒ½é€‰æ‹©ï¼ˆä¼˜å…ˆæœ¬åœ°ï¼‰
    ByPerformance,

    /// æŒ‰å¯ç”¨æ€§é€‰æ‹©ï¼ˆå¥åº·æ£€æŸ¥ï¼‰
    ByAvailability,

    /// è‡ªå®šä¹‰é€‰æ‹©
    Custom(Box<dyn Fn(&SandboxRequest) -> SandboxType>),
}

impl SandboxManager {
    /// æ ¹æ®ç­–ç•¥é€‰æ‹©æ²™ç®±
    pub async fn execute_with_strategy(
        &self,
        request: SandboxRequest,
        strategy: SandboxSelectionStrategy,
    ) -> Result<SandboxResult, SandboxError> {
        match strategy {
            SandboxSelectionStrategy::ByLanguage => {
                // é»˜è®¤è¡Œä¸ºï¼šæŒ‰è¯­è¨€é€‰æ‹©
                self.execute(request).await
            }

            SandboxSelectionStrategy::ByPerformance => {
                // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°æ²™ç®±ï¼ˆV8/WASMï¼‰ï¼Œå¤±è´¥æ—¶é™çº§åˆ°è¿œç¨‹
                match self.execute(request.clone()).await {
                    Ok(result) => Ok(result),
                    Err(_) if self.has_remote_sandbox() => {
                        // é™çº§åˆ°è¿œç¨‹æ²™ç®±
                        let remote_sandbox = self.get_remote_sandbox();
                        remote_sandbox.execute(request).await
                    }
                    Err(e) => Err(e),
                }
            }

            SandboxSelectionStrategy::ByAvailability => {
                // æ£€æŸ¥å¥åº·çŠ¶æ€ï¼Œé€‰æ‹©å¥åº·çš„æ²™ç®±
                let health_statuses = self.health_check_all().await;

                for (sandbox_type, status) in health_statuses {
                    if status == HealthStatus::Healthy {
                        if let Some(sandbox) = self.get_sandbox_by_type(sandbox_type) {
                            if sandbox.supported_languages().contains(&request.language) {
                                return sandbox.execute(request).await;
                            }
                        }
                    }
                }

                Err(SandboxError::SandboxUnavailable(
                    "No healthy sandbox available".to_string()
                ))
            }

            SandboxSelectionStrategy::Custom(selector) => {
                let sandbox_type = selector(&request);
                let sandbox = self.get_sandbox_by_type(sandbox_type)
                    .ok_or_else(|| SandboxError::SandboxUnavailable(
                        format!("Sandbox {:?} not available", sandbox_type)
                    ))?;

                sandbox.execute(request).await
            }
        }
    }
}
```

### 8.4 ç›‘æ§å’Œæ—¥å¿—

```rust
/// æ²™ç®±æ‰§è¡Œç›‘æ§
pub struct SandboxMonitor {
    metrics: Arc<SandboxMetrics>,
}

impl SandboxMonitor {
    /// åŒ…è£…æ²™ç®±æ‰§è¡Œï¼Œæ·»åŠ ç›‘æ§
    pub async fn execute_with_monitoring<S: CodeSandbox>(
        &self,
        sandbox: &S,
        request: SandboxRequest,
    ) -> Result<SandboxResult, SandboxError> {
        let start_time = Instant::now();
        let sandbox_type = sandbox.sandbox_type();

        // è®°å½•å¼€å§‹
        tracing::info!(
            sandbox_type = ?sandbox_type,
            language = ?request.language,
            "Sandbox execution started"
        );

        // æ‰§è¡Œ
        let result = sandbox.execute(request).await;

        // è®°å½•ç»“æŸ
        let duration = start_time.elapsed();
        let success = result.is_ok();

        tracing::info!(
            sandbox_type = ?sandbox_type,
            success = success,
            duration_ms = duration.as_millis(),
            "Sandbox execution completed"
        );

        // æ›´æ–°æŒ‡æ ‡
        self.metrics.record_execution(sandbox_type, duration, success);

        result
    }
}

/// Prometheus æŒ‡æ ‡
pub struct SandboxMetrics {
    executions_total: IntCounterVec,
    execution_duration: HistogramVec,
    memory_usage: HistogramVec,
    errors_total: IntCounterVec,
}

impl SandboxMetrics {
    pub fn new() -> Self {
        let executions_total = IntCounterVec::new(
            Opts::new("sandbox_executions_total", "Total sandbox executions"),
            &["sandbox_type", "language"]
        ).unwrap();

        let execution_duration = HistogramVec::new(
            HistogramOpts::new("sandbox_execution_duration_seconds", "Execution duration"),
            &["sandbox_type", "language"]
        ).unwrap();

        Self {
            executions_total,
            execution_duration,
            memory_usage: HistogramVec::new(...).unwrap(),
            errors_total: IntCounterVec::new(...).unwrap(),
        }
    }

    pub fn record_execution(
        &self,
        sandbox_type: SandboxType,
        duration: Duration,
        success: bool,
    ) {
        let type_label = format!("{:?}", sandbox_type);

        self.executions_total
            .with_label_values(&[&type_label, "unknown"])
            .inc();

        self.execution_duration
            .with_label_values(&[&type_label, "unknown"])
            .observe(duration.as_secs_f64());

        if !success {
            self.errors_total
                .with_label_values(&[&type_label, "unknown"])
                .inc();
        }
    }
}
```

---

## 9. æ€§èƒ½ä¼˜åŒ–

```rust
// src/nodes/data_transform/code.rs

use crate::sandbox::v8::{V8SandboxManager, SandboxConfig};

pub struct CodeNodeExecutor {
    sandbox_manager: Arc<V8SandboxManager>,
}

impl CodeNodeExecutor {
    pub fn new() -> Self {
        let config = SandboxConfig::default();
        let sandbox_manager = Arc::new(V8SandboxManager::new(config));

        Self { sandbox_manager }
    }
}

#[async_trait]
impl NodeExecutor for CodeNodeExecutor {
    fn validate(&self, config: &Value) -> Result<(), NodeError> {
        let config: CodeNodeConfig = serde_json::from_value(config.clone())?;

        // éªŒè¯è¯­è¨€ç±»å‹
        if config.language != CodeLanguage::Javascript {
            return Err(NodeError::ConfigError(
                "Only JavaScript is supported".to_string()
            ));
        }

        // éªŒè¯ä»£ç ä¸ä¸ºç©º
        if config.code.trim().is_empty() {
            return Err(NodeError::ConfigError(
                "Code cannot be empty".to_string()
            ));
        }

        Ok(())
    }

    async fn execute(
        &self,
        ctx: &NodeContext,
        pool: &Arc<RwLock<VariablePool>>,
        event_sender: &EventSender,
    ) -> Result<NodeExecutionResult, NodeError> {
        let config: CodeNodeConfig = serde_json::from_value(ctx.config.clone())?;

        // 1. ä»å˜é‡æ± è¯»å–è¾“å…¥
        let pool_read = pool.read().await;
        let mut inputs = json!({});

        for (var_name, var_selector) in &config.inputs {
            if let Some(value) = pool_read.get_value(var_selector) {
                inputs[var_name] = value;
            }
        }
        drop(pool_read);

        // 2. æ‰§è¡Œ JavaScript ä»£ç 
        let result = self.sandbox_manager
            .execute(&config.code, inputs)
            .await
            .map_err(|e| NodeError::ExecutionError(e.to_string()))?;

        // 3. è¿”å›ç»“æœ
        Ok(NodeExecutionResult::Completed(json!({
            config.output_variable: result,
        })))
    }

    fn node_type(&self) -> &str {
        "code"
    }
}
```

### 6.2 å®‰å…¨ Console å®ç°

```rust
impl V8Sandbox {
    fn setup_safe_console(
        &self,
        scope: &mut v8::HandleScope,
        global: v8::Local<v8::Object>,
    ) -> Result<(), SandboxError> {
        // åˆ›å»º console å¯¹è±¡
        let console = v8::Object::new(scope);

        // å®ç° console.log
        let log_fn = v8::Function::new(scope, |scope, args| {
            let mut output = Vec::new();

            for i in 0..args.len() {
                let arg = args.get(i);
                let string = arg.to_string(scope).unwrap();
                output.push(string.to_rust_string_lossy(scope));
            }

            // ä½¿ç”¨ tracing è®°å½•æ—¥å¿—
            tracing::info!("[JS Console] {}", output.join(" "));

            v8::undefined(scope).into()
        }).unwrap();

        let log_key = v8::String::new(scope, "log").unwrap();
        console.set(scope, log_key.into(), log_fn.into());

        // è®¾ç½®åˆ°å…¨å±€å¯¹è±¡
        let console_key = v8::String::new(scope, "console").unwrap();
        global.set(scope, console_key.into(), console.into());

        Ok(())
    }
}
```

### 6.3 Isolate æ± ç®¡ç†

```rust
pub struct IsolatePool {
    pool: Arc<Mutex<VecDeque<v8::OwnedIsolate>>>,
    config: SandboxConfig,
    stats: Arc<RwLock<PoolStats>>,
}

impl IsolatePool {
    pub fn new(config: SandboxConfig) -> Self {
        let pool = Arc::new(Mutex::new(VecDeque::new()));

        // é¢„çƒ­æ± 
        let mut pool_lock = pool.blocking_lock();
        for _ in 0..config.pool_size {
            let isolate = Self::create_isolate(&config);
            pool_lock.push_back(isolate);
        }
        drop(pool_lock);

        Self {
            pool,
            config,
            stats: Arc::new(RwLock::new(PoolStats::default())),
        }
    }

    pub async fn acquire(&self) -> Result<v8::OwnedIsolate, SandboxError> {
        let mut pool = self.pool.lock().await;

        if let Some(isolate) = pool.pop_front() {
            // æ›´æ–°ç»Ÿè®¡
            let mut stats = self.stats.write().await;
            stats.acquired += 1;

            Ok(isolate)
        } else {
            // æ± ä¸ºç©ºï¼Œåˆ›å»ºæ–°çš„
            Ok(Self::create_isolate(&self.config))
        }
    }

    pub async fn release(&self, isolate: v8::OwnedIsolate) {
        let mut pool = self.pool.lock().await;

        if pool.len() < self.config.pool_size {
            pool.push_back(isolate);

            // æ›´æ–°ç»Ÿè®¡
            let mut stats = self.stats.write().await;
            stats.released += 1;
        }
    }

    fn create_isolate(config: &SandboxConfig) -> v8::OwnedIsolate {
        let mut params = v8::CreateParams::default();
        params = params.heap_limits(0, config.max_heap_size);

        v8::Isolate::new(params)
    }
}

#[derive(Default)]
struct PoolStats {
    acquired: u64,
    released: u64,
    created: u64,
}
```

### 6.4 å¿«ç…§ä¼˜åŒ–

```rust
// ä½¿ç”¨å¿«ç…§åŠ é€Ÿå¯åŠ¨
pub struct V8SandboxWithSnapshot {
    snapshot_blob: &'static [u8],
    config: SandboxConfig,
}

impl V8SandboxWithSnapshot {
    pub fn new_with_snapshot(config: SandboxConfig) -> Self {
        // åˆ›å»ºåŒ…å«å¸¸ç”¨åº“çš„å¿«ç…§
        let snapshot_blob = Self::create_snapshot();

        Self {
            snapshot_blob,
            config,
        }
    }

    fn create_snapshot() -> &'static [u8] {
        // åˆ›å»ºå¿«ç…§åˆ›å»ºå™¨
        let mut snapshot_creator = v8::SnapshotCreator::new(None);

        {
            let isolate = snapshot_creator.get_owned_isolate();
            let scope = &mut v8::HandleScope::new(isolate);
            let context = v8::Context::new(scope);
            let scope = &mut v8::ContextScope::new(scope, context);

            // é¢„åŠ è½½å¸¸ç”¨åº“å’Œå‡½æ•°
            let init_code = r#"
                // å¸¸ç”¨å·¥å…·å‡½æ•°
                globalThis.__utils__ = {
                    deepClone: function(obj) {
                        return JSON.parse(JSON.stringify(obj));
                    },
                    isEmpty: function(value) {
                        return value === null || value === undefined || value === '';
                    }
                };
            "#;

            let code = v8::String::new(scope, init_code).unwrap();
            let script = v8::Script::compile(scope, code, None).unwrap();
            script.run(scope);

            snapshot_creator.set_default_context(context);
        }

        // åˆ›å»ºå¿«ç…§
        let snapshot = snapshot_creator.create_blob(
            v8::FunctionCodeHandling::Keep
        ).unwrap();

        Box::leak(snapshot.into_boxed_slice())
    }

    pub fn create_isolate(&self) -> v8::OwnedIsolate {
        let mut params = v8::CreateParams::default();
        params = params.heap_limits(0, self.config.max_heap_size);
        params = params.snapshot_blob(self.snapshot_blob);

        v8::Isolate::new(params)
    }
}
```

---

## 7. æ€§èƒ½ä¼˜åŒ–

### 7.1 ä¼˜åŒ–ç­–ç•¥

| ç­–ç•¥ | è¯´æ˜ | æ€§èƒ½æå‡ |
|------|------|---------|
| **Isolate æ± ** | å¤ç”¨ V8 Isolateï¼Œé¿å…é‡å¤åˆ›å»º | 10-20x |
| **å¿«ç…§** | é¢„ç¼–è¯‘å¸¸ç”¨ä»£ç ï¼ŒåŠ é€Ÿå¯åŠ¨ | 2-3x |
| **JIT ç¼–è¯‘** | V8 è‡ªåŠ¨ä¼˜åŒ–çƒ­ç‚¹ä»£ç  | 5-10x |
| **å¹¶è¡Œæ‰§è¡Œ** | å¤šä¸ª Isolate å¹¶è¡Œå¤„ç† | Nx |

### 7.2 æ€§èƒ½åŸºå‡†

```rust
#[cfg(test)]
mod benchmarks {
    use super::*;
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn bench_simple_execution(c: &mut Criterion) {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                return { result: inputs.value * 2 };
            }
        "#;

        let inputs = json!({ "value": 42 });

        c.bench_function("simple_execution", |b| {
            b.iter(|| {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async {
                    manager.execute(black_box(code), black_box(inputs.clone())).await
                })
            });
        });
    }

    fn bench_complex_execution(c: &mut Criterion) {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                const { numbers } = inputs;

                // å¤æ‚è®¡ç®—
                const result = numbers
                    .map(n => n * 2)
                    .filter(n => n > 10)
                    .reduce((sum, n) => sum + n, 0);

                return { result };
            }
        "#;

        let inputs = json!({
            "numbers": (1..=100).collect::<Vec<_>>()
        });

        c.bench_function("complex_execution", |b| {
            b.iter(|| {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async {
                    manager.execute(black_box(code), black_box(inputs.clone())).await
                })
            });
        });
    }

    criterion_group!(benches, bench_simple_execution, bench_complex_execution);
    criterion_main!(benches);
}
```

### 7.3 æ€§èƒ½æŒ‡æ ‡

| åœºæ™¯ | å†·å¯åŠ¨ | çƒ­å¯åŠ¨ï¼ˆæ± ï¼‰ | ååé‡ |
|------|--------|-------------|--------|
| ç®€å•è®¡ç®— | 5-10ms | 0.5-1ms | 1000 req/s |
| å¤æ‚è®¡ç®— | 10-20ms | 2-5ms | 500 req/s |
| å¤§æ•°æ®å¤„ç† | 50-100ms | 10-20ms | 100 req/s |

---

## 8. æµ‹è¯•ç­–ç•¥

### 8.1 å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_simple_execution() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                return { result: inputs.a + inputs.b };
            }
        "#;

        let inputs = json!({ "a": 1, "b": 2 });
        let result = manager.execute(code, inputs).await.unwrap();

        assert_eq!(result["result"], 3);
    }

    #[tokio::test]
    async fn test_array_operations() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                const doubled = inputs.numbers.map(n => n * 2);
                const sum = doubled.reduce((a, b) => a + b, 0);
                return { doubled, sum };
            }
        "#;

        let inputs = json!({ "numbers": [1, 2, 3, 4, 5] });
        let result = manager.execute(code, inputs).await.unwrap();

        assert_eq!(result["doubled"], json!([2, 4, 6, 8, 10]));
        assert_eq!(result["sum"], 30);
    }

    #[tokio::test]
    async fn test_string_operations() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                const upper = inputs.text.toUpperCase();
                const words = inputs.text.split(' ');
                return { upper, wordCount: words.length };
            }
        "#;

        let inputs = json!({ "text": "hello world" });
        let result = manager.execute(code, inputs).await.unwrap();

        assert_eq!(result["upper"], "HELLO WORLD");
        assert_eq!(result["wordCount"], 2);
    }

    #[tokio::test]
    async fn test_json_operations() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                const parsed = JSON.parse(inputs.jsonString);
                const stringified = JSON.stringify(parsed);
                return { parsed, stringified };
            }
        "#;

        let inputs = json!({ "jsonString": r#"{"key":"value"}"# });
        let result = manager.execute(code, inputs).await.unwrap();

        assert_eq!(result["parsed"]["key"], "value");
    }
}
```

### 8.2 å®‰å…¨æµ‹è¯•

```rust
#[cfg(test)]
mod security_tests {
    use super::*;

    #[tokio::test]
    async fn test_eval_blocked() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                eval("console.log('hacked')");
                return {};
            }
        "#;

        let result = manager.execute(code, json!({})).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_require_blocked() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                const fs = require('fs');
                return {};
            }
        "#;

        let result = manager.execute(code, json!({})).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_proto_pollution_blocked() {
        let manager = V8SandboxManager::new(SandboxConfig::default());

        let code = r#"
            function main(inputs) {
                Object.prototype.polluted = 'hacked';
                return {};
            }
        "#;

        let result = manager.execute(code, json!({})).await;
        // åº”è¯¥æ‰§è¡ŒæˆåŠŸï¼Œä½†æ±¡æŸ“ä¸åº”å½±å“å…¶ä»–æ‰§è¡Œ
        assert!(result.is_ok());

        // éªŒè¯éš”ç¦»æ€§
        let code2 = r#"
            function main(inputs) {
                return { polluted: ({}).polluted };
            }
        "#;

        let result2 = manager.execute(code2, json!({})).await.unwrap();
        assert_eq!(result2["polluted"], json!(null));
    }

    #[tokio::test]
    async fn test_memory_limit() {
        let mut config = SandboxConfig::default();
        config.max_heap_size = 10 * 1024 * 1024;  // 10MB

        let manager = V8SandboxManager::new(config);

        let code = r#"
            function main(inputs) {
                // å°è¯•åˆ†é…å¤§é‡å†…å­˜
                const arr = [];
                for (let i = 0; i < 10000000; i++) {
                    arr.push({ data: new Array(1000).fill(i) });
                }
                return { length: arr.length };
            }
        "#;

        let result = manager.execute(code, json!({})).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), SandboxError::MemoryLimitExceeded));
    }

    #[tokio::test]
    async fn test_execution_timeout() {
        let mut config = SandboxConfig::default();
        config.execution_timeout = Duration::from_secs(1);

        let manager = V8SandboxManager::new(config);

        let code = r#"
            function main(inputs) {
                // æ— é™å¾ªç¯
                while (true) {}
                return {};
            }
        "#;

        let result = manager.execute(code, json!({})).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), SandboxError::ExecutionTimeout));
    }
}
```

### 8.3 é›†æˆæµ‹è¯•

```rust
#[tokio::test]
async fn test_code_node_integration() {
    // åˆ›å»ºå®Œæ•´çš„å·¥ä½œæµ
    let dsl = r#"
    nodes:
      - id: start
        type: start
      - id: code1
        type: code
        data:
          language: javascript
          code: |
            function main(inputs) {
                const { numbers } = inputs;
                const sum = numbers.reduce((a, b) => a + b, 0);
                const avg = sum / numbers.length;
                return { sum, avg };
            }
          inputs:
            numbers: "input.numbers"
          output_variable: "result"
      - id: end
        type: end
    edges:
      - source: start
        target: code1
      - source: code1
        target: end
    "#;

    let inputs = json!({
        "numbers": [1, 2, 3, 4, 5]
    });

    let result = execute_workflow(dsl, inputs).await.unwrap();

    assert_eq!(result["result"]["sum"], 15);
    assert_eq!(result["result"]["avg"], 3);
}
```

---

## 9. ä½¿ç”¨ç¤ºä¾‹

## 11. ä½¿ç”¨ç¤ºä¾‹

### 11.1 åŸºç¡€ä½¿ç”¨

```rust
use xworkflow::sandbox::{SandboxManager, SandboxRequest, CodeLanguage, ExecutionConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºæ²™ç®±ç®¡ç†å™¨
    let manager = SandboxManager::new(SandboxManagerConfig::default());

    // JavaScript ç¤ºä¾‹
    let js_request = SandboxRequest {
        code: r#"
            function main(inputs) {
                const { numbers } = inputs;
                const sum = numbers.reduce((a, b) => a + b, 0);
                return { sum };
            }
        "#.to_string(),
        language: CodeLanguage::JavaScript,
        inputs: json!({ "numbers": [1, 2, 3, 4, 5] }),
        config: ExecutionConfig::default(),
    };

    let result = manager.execute(js_request).await?;
    println!("Result: {:?}", result.output);

    Ok(())
}
```

### 11.2 æ‰©å±•æ–°æ²™ç®±ï¼ˆæœªæ¥ï¼‰

```rust
// å½“éœ€è¦æ”¯æŒæ–°è¯­è¨€æ—¶ï¼Œåªéœ€å®ç° CodeSandbox trait
pub struct PythonSandbox {
    // é…ç½®
}

#[async_trait]
impl CodeSandbox for PythonSandbox {
    fn sandbox_type(&self) -> SandboxType {
        SandboxType::Python
    }

    fn supported_languages(&self) -> Vec<CodeLanguage> {
        vec![CodeLanguage::Python]
    }

    async fn execute(&self, request: SandboxRequest) -> Result<SandboxResult, SandboxError> {
        // å®ç° Python ä»£ç æ‰§è¡Œé€»è¾‘
        // å¯ä»¥é€šè¿‡è¿œç¨‹æœåŠ¡æˆ–åµŒå…¥ pyo3
        todo!()
    }
}

// æ³¨å†Œåˆ°ç®¡ç†å™¨
manager.register_sandbox(
    CodeLanguage::Python,
    Arc::new(PythonSandbox::new())
);

// ä½¿ç”¨
let result = manager.execute(SandboxRequest {
    code: "def main(inputs):\n    return {'result': 'Python'}".to_string(),
    language: CodeLanguage::Python,
    inputs: json!({}),
    config: ExecutionConfig::default(),
}).await?;
```

### 11.3 é”™è¯¯å¤„ç†

```rust
match manager.execute(request).await {
    Ok(result) => {
        if result.success {
            println!("Output: {:?}", result.output);
        } else {
            eprintln!("Execution failed: {}", result.error.unwrap_or_default());
        }
    }
    Err(SandboxError::ExecutionTimeout) => {
        eprintln!("Code execution timed out");
    }
    Err(SandboxError::MemoryLimitExceeded) => {
        eprintln!("Memory limit exceeded");
    }
    Err(SandboxError::UnsupportedLanguage(lang)) => {
        eprintln!("Language {:?} is not supported", lang);
    }
    Err(e) => {
        eprintln!("Sandbox error: {}", e);
    }
}
```

### 11.4 å¥åº·æ£€æŸ¥å’Œç›‘æ§

```rust
// æ£€æŸ¥ V8 æ²™ç®±å¥åº·çŠ¶æ€
let health_statuses = manager.health_check_all().await;

for (sandbox_type, status) in health_statuses {
    println!("{:?}: {:?}", sandbox_type, status);
}

// è·å– V8 ç»Ÿè®¡ä¿¡æ¯
if let Some(v8_sandbox) = manager.get_sandbox_by_type(SandboxType::V8) {
    let stats = v8_sandbox.get_stats().await?;
    println!("V8 Stats: {:?}", stats);
}
```

---

## 12. é£é™©ä¸é™åˆ¶

```javascript
function main(inputs) {
    const { text, numbers } = inputs;

    // å­—ç¬¦ä¸²å¤„ç†
    const processed = text
        .toLowerCase()
        .split(' ')
        .filter(word => word.length > 3)
        .join('-');

    // æ•°ç»„å¤„ç†
    const stats = {
        sum: numbers.reduce((a, b) => a + b, 0),
        avg: numbers.reduce((a, b) => a + b, 0) / numbers.length,
        max: Math.max(...numbers),
        min: Math.min(...numbers)
    };

    return {
        processed,
        stats
    };
}
```

### 9.2 JSON æ•°æ®è½¬æ¢

```javascript
function main(inputs) {
    const { users } = inputs;

    // æ•°æ®è½¬æ¢å’Œè¿‡æ»¤
    const activeUsers = users
        .filter(user => user.status === 'active')
        .map(user => ({
            id: user.id,
            name: user.name,
            email: user.email,
            joinedDays: Math.floor(
                (Date.now() - new Date(user.joinedAt).getTime()) / (1000 * 60 * 60 * 24)
            )
        }));

    // åˆ†ç»„ç»Ÿè®¡
    const byRole = activeUsers.reduce((acc, user) => {
        acc[user.role] = (acc[user.role] || 0) + 1;
        return acc;
    }, {});

    return {
        activeUsers,
        totalActive: activeUsers.length,
        byRole
    };
}
```

### 9.3 å¤æ‚ä¸šåŠ¡é€»è¾‘

```javascript
function main(inputs) {
    const { orders, products } = inputs;

    // è®¢å•å¤„ç†
    const processedOrders = orders.map(order => {
        // è®¡ç®—è®¢å•æ€»é¢
        const total = order.items.reduce((sum, item) => {
            const product = products.find(p => p.id === item.productId);
            return sum + (product ? product.price * item.quantity : 0);
        }, 0);

        // åº”ç”¨æŠ˜æ‰£
        const discount = total > 100 ? total * 0.1 : 0;
        const finalTotal = total - discount;

        return {
            orderId: order.id,
            itemCount: order.items.length,
            subtotal: total,
            discount,
            total: finalTotal,
            status: finalTotal > 0 ? 'valid' : 'invalid'
        };
    });

    // ç»Ÿè®¡
    const summary = {
        totalOrders: processedOrders.length,
        validOrders: processedOrders.filter(o => o.status === 'valid').length,
        totalRevenue: processedOrders.reduce((sum, o) => sum + o.total, 0)
    };

    return {
        orders: processedOrders,
        summary
    };
}
```

### 9.4 æ–‡æœ¬åˆ†æ

```javascript
function main(inputs) {
    const { text } = inputs;

    // åˆ†è¯
    const words = text
        .toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 0);

    // è¯é¢‘ç»Ÿè®¡
    const wordFreq = words.reduce((freq, word) => {
        freq[word] = (freq[word] || 0) + 1;
        return freq;
    }, {});

    // æ’åº
    const topWords = Object.entries(wordFreq)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([word, count]) => ({ word, count }));

    return {
        totalWords: words.length,
        uniqueWords: Object.keys(wordFreq).length,
        topWords
    };
}
```

### 9.5 æ•°æ®éªŒè¯

```javascript
function main(inputs) {
    const { data } = inputs;

    const errors = [];

    // éªŒè¯å¿…å¡«å­—æ®µ
    const requiredFields = ['name', 'email', 'age'];
    for (const field of requiredFields) {
        if (!data[field]) {
            errors.push(`${field} is required`);
        }
    }

    // éªŒè¯é‚®ç®±æ ¼å¼
    if (data.email && !data.email.includes('@')) {
        errors.push('Invalid email format');
    }

    // éªŒè¯å¹´é¾„èŒƒå›´
    if (data.age && (data.age < 0 || data.age > 150)) {
        errors.push('Age must be between 0 and 150');
    }

    return {
        valid: errors.length === 0,
        errors,
        data: errors.length === 0 ? data : null
    };
}
```

---

## 10. é£é™©ä¸é™åˆ¶

### 10.1 å·²çŸ¥é™åˆ¶

| é™åˆ¶ | è¯´æ˜ | å½±å“ |
|------|------|------|
| **æ— å¼‚æ­¥æ”¯æŒ** | ä¸æ”¯æŒ async/awaitã€Promise | æ— æ³•æ‰§è¡Œå¼‚æ­¥æ“ä½œ |
| **æ— ç½‘ç»œè®¿é—®** | ä¸æ”¯æŒ fetchã€XMLHttpRequest | æ— æ³•è°ƒç”¨å¤–éƒ¨ API |
| **æ— æ–‡ä»¶ç³»ç»Ÿ** | ä¸æ”¯æŒ fs æ¨¡å— | æ— æ³•è¯»å†™æ–‡ä»¶ |
| **æ— å®šæ—¶å™¨** | ä¸æ”¯æŒ setTimeout/setInterval | æ— æ³•å»¶è¿Ÿæ‰§è¡Œ |
| **å†…å­˜é™åˆ¶** | é»˜è®¤ 128MB å †å†…å­˜ | å¤§æ•°æ®å¤„ç†å—é™ |
| **æ‰§è¡Œè¶…æ—¶** | é»˜è®¤ 30 ç§’è¶…æ—¶ | é•¿æ—¶é—´è®¡ç®—å—é™ |

### 10.2 å®‰å…¨é£é™©

| é£é™© | ç¼“è§£æªæ–½ | æ®‹ç•™é£é™© |
|------|---------|---------|
| **åŸå‹é“¾æ±¡æŸ“** | Isolate éš”ç¦» | ä½ |
| **å†…å­˜è€—å°½** | å †å†…å­˜é™åˆ¶ | ä½ |
| **CPU å ç”¨** | æ‰§è¡Œè¶…æ—¶ | ä¸­ |
| **ä»£ç æ³¨å…¥** | ä»£ç éªŒè¯ | ä½ |
| **ä¿¡æ¯æ³„éœ²** | API ç™½åå• | ä½ |

### 10.3 æ€§èƒ½é£é™©

| é£é™© | è¯´æ˜ | ç¼“è§£æªæ–½ |
|------|------|---------|
| **å†·å¯åŠ¨æ…¢** | é¦–æ¬¡åˆ›å»º Isolate è¾ƒæ…¢ | ä½¿ç”¨ Isolate æ± é¢„çƒ­ |
| **å†…å­˜å ç”¨é«˜** | æ¯ä¸ª Isolate å ç”¨ ~10MB | é™åˆ¶æ± å¤§å°ï¼ŒåŠæ—¶å›æ”¶ |
| **ç¼–è¯‘å¼€é”€** | V8 ç¼–è¯‘æ—¶é—´ | ä½¿ç”¨å¿«ç…§é¢„ç¼–è¯‘ |

### 10.4 å…¼å®¹æ€§é—®é¢˜

**ä¸æ”¯æŒçš„ ES ç‰¹æ€§**:
- ES Modules (import/export)
- Top-level await
- Worker threads
- SharedArrayBuffer
- Atomics

**è§£å†³æ–¹æ¡ˆ**:
- ä½¿ç”¨ ES5/ES6 å…¼å®¹è¯­æ³•
- é¿å…ä½¿ç”¨æ¨¡å—ç³»ç»Ÿ
- ä½¿ç”¨åŒæ­¥ä»£ç 

### 10.5 è°ƒè¯•å›°éš¾

**é—®é¢˜**:
- æ— æ³•ä½¿ç”¨æµè§ˆå™¨ DevTools
- é”™è¯¯å †æ ˆä¿¡æ¯æœ‰é™
- æ— æ³•æ–­ç‚¹è°ƒè¯•

**è§£å†³æ–¹æ¡ˆ**:
- æä¾›è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
- æ”¯æŒ console.log è¾“å‡º
- æä¾›ä»£ç éªŒè¯å·¥å…·

---

## 11. æœªæ¥æ”¹è¿›

### 11.1 çŸ­æœŸæ”¹è¿›ï¼ˆ1-3 ä¸ªæœˆï¼‰

- [ ] **TypeScript æ”¯æŒ**: é›†æˆ SWC æˆ– esbuild ç¼–è¯‘ TypeScript
- [ ] **æ›´å¥½çš„é”™è¯¯ä¿¡æ¯**: æä¾›æºç ä½ç½®å’Œå †æ ˆè¿½è¸ª
- [ ] **è°ƒè¯•æ¨¡å¼**: æ”¯æŒ console.log è¾“å‡ºåˆ°æ—¥å¿—
- [ ] **æ€§èƒ½ç›‘æ§**: è®°å½•æ‰§è¡Œæ—¶é—´ã€å†…å­˜ä½¿ç”¨ç­‰æŒ‡æ ‡

### 11.2 ä¸­æœŸæ”¹è¿›ï¼ˆ3-6 ä¸ªæœˆï¼‰

- [ ] **å¼‚æ­¥æ”¯æŒ**: å®ç°å—é™çš„ Promise æ”¯æŒ
- [ ] **æ¨¡å—ç³»ç»Ÿ**: æ”¯æŒé¢„å®šä¹‰çš„å®‰å…¨æ¨¡å—
- [ ] **æ›´å¤šå†…ç½®åº“**: lodashã€moment ç­‰å¸¸ç”¨åº“
- [ ] **ä»£ç ç¼“å­˜**: ç¼“å­˜ç¼–è¯‘åçš„ä»£ç 

### 11.3 é•¿æœŸæ”¹è¿›ï¼ˆ6-12 ä¸ªæœˆï¼‰

- [ ] **WebAssembly æ”¯æŒ**: å…è®¸è¿è¡Œ WASM æ¨¡å—
- [ ] **å¤šè¯­è¨€æ”¯æŒ**: Pythonã€Lua ç­‰å…¶ä»–è¯­è¨€
- [ ] **åˆ†å¸ƒå¼æ‰§è¡Œ**: æ”¯æŒä»£ç åœ¨å¤šä¸ªèŠ‚ç‚¹æ‰§è¡Œ
- [ ] **GPU åŠ é€Ÿ**: åˆ©ç”¨ GPU è¿›è¡Œè®¡ç®—å¯†é›†å‹ä»»åŠ¡

---

## 12. éƒ¨ç½²æŒ‡å—

### 12.1 ä¾èµ–å®‰è£…

```toml
# Cargo.toml
[dependencies]
rusty_v8 = "0.85"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.35", features = ["full"] }
thiserror = "1.0"
tracing = "0.1"
regex = "1"
```

### 12.2 ç¼–è¯‘é…ç½®

```bash
# è®¾ç½® V8 ç¼–è¯‘é€‰é¡¹
export V8_FROM_SOURCE=1  # ä»æºç ç¼–è¯‘ï¼ˆå¯é€‰ï¼‰
export RUSTY_V8_MIRROR=https://github.com/denoland/rusty_v8/releases/download  # ä½¿ç”¨é•œåƒ

# ç¼–è¯‘é¡¹ç›®
cargo build --release
```

### 12.3 è¿è¡Œæ—¶é…ç½®

```rust
// åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–
fn main() {
    // åˆå§‹åŒ– V8 å¹³å°ï¼ˆå…¨å±€ä¸€æ¬¡ï¼‰
    let platform = v8::new_default_platform(0, false).make_shared();
    v8::V8::initialize_platform(platform);
    v8::V8::initialize();

    // åˆ›å»ºæ²™ç®±ç®¡ç†å™¨
    let config = SandboxConfig {
        max_heap_size: 128 * 1024 * 1024,  // 128MB
        execution_timeout: Duration::from_secs(30),
        max_stack_depth: 100,
        enable_isolate_pool: true,
        pool_size: 10,
    };

    let sandbox_manager = V8SandboxManager::new(config);

    // ä½¿ç”¨æ²™ç®±ç®¡ç†å™¨
    // ...
}
```

### 12.4 ç›‘æ§æŒ‡æ ‡

```rust
// æš´éœ² Prometheus æŒ‡æ ‡
use prometheus::{Counter, Histogram, Registry};

pub struct SandboxMetrics {
    executions_total: Counter,
    execution_duration: Histogram,
    memory_usage: Histogram,
    errors_total: Counter,
}

impl SandboxMetrics {
    pub fn new(registry: &Registry) -> Self {
        let executions_total = Counter::new(
            "sandbox_executions_total",
            "Total number of sandbox executions"
        ).unwrap();

        let execution_duration = Histogram::new(
            "sandbox_execution_duration_seconds",
            "Sandbox execution duration in seconds"
        ).unwrap();

        registry.register(Box::new(executions_total.clone())).unwrap();
        registry.register(Box::new(execution_duration.clone())).unwrap();

        Self {
            executions_total,
            execution_duration,
            memory_usage: Histogram::new(...).unwrap(),
            errors_total: Counter::new(...).unwrap(),
        }
    }

    pub fn record_execution(&self, duration: Duration, success: bool) {
        self.executions_total.inc();
        self.execution_duration.observe(duration.as_secs_f64());

        if !success {
            self.errors_total.inc();
        }
    }
}
```

---

## 13. å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆé€‰æ‹© V8 è€Œä¸æ˜¯å…¶ä»– JS å¼•æ“ï¼Ÿ

**A**: V8 æ˜¯æœ€æˆç†Ÿã€æ€§èƒ½æœ€å¥½çš„ JavaScript å¼•æ“ï¼Œè¢« Chromeã€Node.jsã€Deno ç­‰å¹¿æ³›ä½¿ç”¨ã€‚rusty_v8 æä¾›äº†å®Œæ•´çš„ Rust ç»‘å®šã€‚

### Q2: V8 æ²™ç®±æ˜¯å¦å®Œå…¨å®‰å…¨ï¼Ÿ

**A**: æ²¡æœ‰ç»å¯¹çš„å®‰å…¨ã€‚æˆ‘ä»¬é€šè¿‡å¤šå±‚éš”ç¦»ï¼ˆIsolateã€Contextã€API ç™½åå•ï¼‰æä¾›äº†å¾ˆå¼ºçš„å®‰å…¨æ€§ï¼Œä½†ä»å»ºè®®ï¼š
- ä¸è¦æ‰§è¡Œå®Œå…¨ä¸å¯ä¿¡çš„ä»£ç 
- è®¾ç½®åˆç†çš„èµ„æºé™åˆ¶
- å®šæœŸæ›´æ–° V8 ç‰ˆæœ¬

### Q3: æ€§èƒ½å¦‚ä½•ï¼Ÿ

**A**:
- å†·å¯åŠ¨ï¼š5-10ms
- çƒ­å¯åŠ¨ï¼ˆæ± ï¼‰ï¼š0.5-1ms
- ç®€å•è®¡ç®—ï¼š< 1ms
- å¤æ‚è®¡ç®—ï¼š2-10ms

### Q4: å¦‚ä½•è°ƒè¯• JavaScript ä»£ç ï¼Ÿ

**A**:
- ä½¿ç”¨ `console.log` è¾“å‡ºåˆ°æ—¥å¿—
- åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­æµ‹è¯•ä»£ç 
- ä½¿ç”¨å•å…ƒæµ‹è¯•éªŒè¯é€»è¾‘

### Q5: æ˜¯å¦æ”¯æŒ npm åŒ…ï¼Ÿ

**A**: ä¸ç›´æ¥æ”¯æŒã€‚ä½†å¯ä»¥ï¼š
- å°†å¸¸ç”¨åº“æ‰“åŒ…åˆ°å¿«ç…§ä¸­
- æä¾›é¢„å®šä¹‰çš„å®‰å…¨æ¨¡å—
- ä½¿ç”¨ CDN åŠ è½½ï¼ˆéœ€è¦ç½‘ç»œæ”¯æŒï¼‰

### Q6: å¦‚ä½•å¤„ç†å¤§æ•°æ®ï¼Ÿ

**A**:
- å¢åŠ å†…å­˜é™åˆ¶
- åˆ†æ‰¹å¤„ç†æ•°æ®
- ä½¿ç”¨æµå¼å¤„ç†
- è€ƒè™‘ä½¿ç”¨å¤–éƒ¨æœåŠ¡

### Q7: æ˜¯å¦æ”¯æŒå¼‚æ­¥æ“ä½œï¼Ÿ

**A**: å½“å‰ç‰ˆæœ¬ä¸æ”¯æŒã€‚æœªæ¥è®¡åˆ’ï¼š
- å®ç°å—é™çš„ Promise æ”¯æŒ
- æä¾›å¼‚æ­¥ API ç™½åå•
- æ”¯æŒ async/await è¯­æ³•

---

## 14. å‚è€ƒèµ„æ–™

- [rusty_v8 æ–‡æ¡£](https://docs.rs/rusty_v8/)
- [V8 å®˜æ–¹æ–‡æ¡£](https://v8.dev/docs)
- [Deno æºç ](https://github.com/denoland/deno) - rusty_v8 çš„ä¸»è¦ä½¿ç”¨è€…
- [V8 åµŒå…¥æŒ‡å—](https://v8.dev/docs/embed)
- [JavaScript å®‰å…¨æœ€ä½³å®è·µ](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html)

---

## é™„å½• A: å®Œæ•´é…ç½®ç¤ºä¾‹

```rust
// src/sandbox/config.rs

use std::time::Duration;

#[derive(Clone, Debug)]
pub struct SandboxConfig {
    /// æœ€å¤§å †å†…å­˜ï¼ˆå­—èŠ‚ï¼‰
    pub max_heap_size: usize,

    /// æ‰§è¡Œè¶…æ—¶
    pub execution_timeout: Duration,

    /// æœ€å¤§æ ˆæ·±åº¦
    pub max_stack_depth: usize,

    /// æ˜¯å¦å¯ç”¨ Isolate æ± 
    pub enable_isolate_pool: bool,

    /// Isolate æ± å¤§å°
    pub pool_size: usize,

    /// æ˜¯å¦å¯ç”¨å¿«ç…§
    pub enable_snapshot: bool,

    /// æ˜¯å¦å¯ç”¨ console.log
    pub enable_console: bool,

    /// æœ€å¤§ä»£ç é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰
    pub max_code_length: usize,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            max_heap_size: 128 * 1024 * 1024,  // 128MB
            execution_timeout: Duration::from_secs(30),
            max_stack_depth: 100,
            enable_isolate_pool: true,
            pool_size: 10,
            enable_snapshot: true,
            enable_console: true,
            max_code_length: 1_000_000,  // 1MB
        }
    }
}

impl SandboxConfig {
    /// å¼€å‘ç¯å¢ƒé…ç½®
    pub fn development() -> Self {
        Self {
            execution_timeout: Duration::from_secs(60),
            enable_console: true,
            ..Default::default()
        }
    }

    /// ç”Ÿäº§ç¯å¢ƒé…ç½®
    pub fn production() -> Self {
        Self {
            max_heap_size: 64 * 1024 * 1024,  // 64MB
            execution_timeout: Duration::from_secs(10),
            enable_console: false,
            ..Default::default()
        }
    }

    /// é«˜æ€§èƒ½é…ç½®
    pub fn high_performance() -> Self {
        Self {
            max_heap_size: 256 * 1024 * 1024,  // 256MB
            pool_size: 20,
            enable_snapshot: true,
            ..Default::default()
        }
    }
}
```

---

---

## é™„å½• B: å®ç°è·¯çº¿å›¾

### é˜¶æ®µ 1: æ ¸å¿ƒæ¥å£ï¼ˆ1 å‘¨ï¼‰
- [ ] å®šä¹‰ `CodeSandbox` trait
- [ ] å®ç° `SandboxManager`
- [ ] å®šä¹‰æ‰€æœ‰æ•°æ®ç»“æ„
- [ ] ç¼–å†™æ¥å£æ–‡æ¡£

### é˜¶æ®µ 2: V8 å®ç°ï¼ˆ2 å‘¨ï¼‰
- [ ] å®ç° `V8Sandbox`
- [ ] Isolate æ± ç®¡ç†
- [ ] å®‰å…¨æœºåˆ¶
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆå¿«ç…§ï¼‰
- [ ] å•å…ƒæµ‹è¯•

### é˜¶æ®µ 3: Code èŠ‚ç‚¹é›†æˆï¼ˆ1 å‘¨ï¼‰
- [ ] æ›´æ–° `CodeNodeExecutor`
- [ ] DSL é…ç½®æ”¯æŒ
- [ ] é›†æˆæµ‹è¯•
- [ ] æ–‡æ¡£æ›´æ–°

### é˜¶æ®µ 4: å…¶ä»–å®ç°ï¼ˆå¯é€‰ï¼ŒæŒ‰éœ€ï¼‰
- [ ] æ ¹æ®å®é™…éœ€æ±‚å®ç°å…¶ä»–æ²™ç®±
- [ ] WASM æ²™ç®±ï¼ˆå¦‚éœ€é«˜æ€§èƒ½äºŒè¿›åˆ¶æ‰§è¡Œï¼‰
- [ ] è¿œç¨‹æ²™ç®±ï¼ˆå¦‚éœ€å¤šè¯­è¨€æ”¯æŒï¼‰
- [ ] å…¶ä»–è¯­è¨€è§£é‡Šå™¨ï¼ˆå¦‚éœ€ç‰¹å®šè¯­è¨€ï¼‰

### é˜¶æ®µ 5: ç›‘æ§å’Œä¼˜åŒ–ï¼ˆ1 å‘¨ï¼‰
- [ ] Prometheus æŒ‡æ ‡
- [ ] æ—¥å¿—å®Œå–„
- [ ] æ€§èƒ½è°ƒä¼˜
- [ ] ç”Ÿäº§éƒ¨ç½²

---

## é™„å½• C: é…ç½®å‚è€ƒ

### å®Œæ•´é…ç½®ç¤ºä¾‹

```rust
// config.toml
[sandbox]
default_type = "v8"

[sandbox.v8]
max_heap_size = 134217728  # 128MB
pool_size = 10
enable_snapshot = true
enable_console = true
max_code_length = 1048576  # 1MB

[sandbox.wasm]
enabled = false
max_memory_pages = 256

[sandbox.remote]
enabled = false
endpoint = "http://sandbox-service:8080"
auth_token = "secret"
connect_timeout_secs = 5
max_retries = 3

[sandbox.execution]
default_timeout_secs = 30
default_max_memory = 134217728  # 128MB
```

### ç¯å¢ƒå˜é‡

```bash
# V8 é…ç½®
SANDBOX_V8_MAX_HEAP_SIZE=134217728
SANDBOX_V8_POOL_SIZE=10

# è¿œç¨‹æ²™ç®±é…ç½®
SANDBOX_REMOTE_ENDPOINT=http://sandbox-service:8080
SANDBOX_REMOTE_AUTH_TOKEN=secret

# æ‰§è¡Œé…ç½®
SANDBOX_DEFAULT_TIMEOUT=30
SANDBOX_DEFAULT_MAX_MEMORY=134217728
```

---

## é™„å½• D: å¸¸è§é—®é¢˜

### Q1: å¦‚ä½•é€‰æ‹©ä½¿ç”¨å“ªç§æ²™ç®±å®ç°ï¼Ÿ

**A**:
- **å½“å‰ç‰ˆæœ¬**: é»˜è®¤ä½¿ç”¨ V8 æ²™ç®±ï¼Œæ”¯æŒ JavaScript
- **æœªæ¥æ‰©å±•**: å¯ä»¥æ ¹æ®éœ€æ±‚å®ç°å…¶ä»–æ²™ç®±ï¼ˆWASMã€è¿œç¨‹æœåŠ¡ç­‰ï¼‰
- **é€‰æ‹©ä¾æ®**: æ ¹æ®è¯­è¨€éœ€æ±‚ã€æ€§èƒ½è¦æ±‚ã€èµ„æºéš”ç¦»éœ€æ±‚ç­‰å› ç´ 

### Q2: å¯ä»¥åŒæ—¶ä½¿ç”¨å¤šä¸ªæ²™ç®±å—ï¼Ÿ

**A**: å¯ä»¥ã€‚`SandboxManager` æ”¯æŒä¸ºä¸åŒè¯­è¨€æ³¨å†Œä¸åŒçš„æ²™ç®±å®ç°ã€‚å½“å‰ç‰ˆæœ¬åªæœ‰ V8ï¼Œæœªæ¥å¯ä»¥æ‰©å±•ã€‚

### Q3: å¦‚ä½•æ·»åŠ æ–°çš„è¯­è¨€æ”¯æŒï¼Ÿ

**A**:
1. æ‰©å±• `CodeLanguage` æšä¸¾æ·»åŠ æ–°è¯­è¨€
2. å®ç° `CodeSandbox` trait
3. åœ¨ `SandboxManager` ä¸­æ³¨å†Œæ–°æ²™ç®±
4. å‚è€ƒç¬¬ 4 ç« çš„æ¥å£é¢„ç•™è¯´æ˜

### Q4: V8 æ²™ç®±çš„æ€§èƒ½å¦‚ä½•ï¼Ÿ

**A**:
- å†·å¯åŠ¨ï¼š5-10ms
- çƒ­å¯åŠ¨ï¼ˆæ± ï¼‰ï¼š0.5-1ms
- ç®€å•è®¡ç®—ï¼š< 1ms
- ååé‡ï¼š1000 req/s

### Q5: å¦‚ä½•ç›‘æ§æ²™ç®±æ€§èƒ½ï¼Ÿ

**A**:
- ä½¿ç”¨ `SandboxMetrics` æ”¶é›† Prometheus æŒ‡æ ‡
- è°ƒç”¨ `get_stats()` è·å–ç»Ÿè®¡ä¿¡æ¯
- ä½¿ç”¨ `health_check()` æ£€æŸ¥å¥åº·çŠ¶æ€

### Q6: æœªæ¥ä¼šæ”¯æŒå“ªäº›è¯­è¨€ï¼Ÿ

**A**: é€šè¿‡æ‰©å±•æ¥å£ï¼Œå¯ä»¥æ”¯æŒï¼š
- Pythonï¼ˆé€šè¿‡è¿œç¨‹æ²™ç®±æˆ– pyo3ï¼‰
- WASMï¼ˆé€šè¿‡ wasmtimeï¼‰
- Luaï¼ˆé€šè¿‡ mluaï¼‰
- å…¶ä»–è¯­è¨€ï¼ˆæ ¹æ®éœ€æ±‚ï¼‰

---

## å˜æ›´å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä½œè€… | å˜æ›´è¯´æ˜ |
|------|------|------|---------|
| v1.0 | 2026-02-09 | Claude | åˆå§‹ç‰ˆæœ¬ï¼ˆV8 å®ç°ï¼‰ |
| v2.0 | 2026-02-09 | Claude | é‡æ„ä¸ºé€šç”¨æ¥å£è®¾è®¡ï¼Œæ”¯æŒå¤šç§å®ç° |

---

**æ–‡æ¡£ç»“æŸ**